<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>Search | Reef</title>
		<meta name="description" content="Enter your search criteria: Search    ">
		

		
		<meta name="viewport" content="width=device-width, initial-scale=1">

		
		<meta name="twitter:card" content="summary">
		<meta name="twitter:site" content="@ChrisFerdinandi">
		<meta property="og:url" content="/search/">
		<meta property="og:title" content="Search">
		<meta property="og:description" content="Enter your search criteria: Search    ">
		

		
		
		<link rel="shortcut icon" href="https://reefjs.com/img/favicon.ico">
		<link rel="icon" sizes="16x16 24x24 32x32 64x64" href="https://reefjs.com/img/favicon.ico">

		
		<style type="text/css">
			/*! gmt-theme v2.6.0 | (c) 2021 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/gmt-theme */
/* pt-serif-regular - latin */
@font-face {
	font-display: swap;
	font-family: "PT Serif";
	font-style: normal;
	font-weight: 400;
	src: local("PT Serif"), local("PTSerif-Regular"), url("https://gomakethings.com/fonts/pt-serif-v11-latin-regular.woff2") format("woff2"), url("https://gomakethings.com/fonts/pt-serif-v11-latin-regular.woff") format("woff");
}
/* pt-serif-italic - latin */
@font-face {
	font-display: swap;
	font-family: "PT Serif";
	font-style: italic;
	font-weight: 400;
	src: local("PT Serif Italic"), local("PTSerif-Italic"), url("https://gomakethings.com/fonts/pt-serif-v11-latin-italic.woff2") format("woff2"), url("https://gomakethings.com/fonts/pt-serif-v11-latin-italic.woff") format("woff");
}
/* pt-serif-700 - latin */
@font-face {
	font-display: swap;
	font-family: "PT Serif";
	font-style: normal;
	font-weight: 700;
	src: local("PT Serif Bold"), local("PTSerif-Bold"), url("https://gomakethings.com/fonts/pt-serif-v11-latin-700.woff2") format("woff2"), url("https://gomakethings.com/fonts/pt-serif-v11-latin-700.woff") format("woff");
}
/* pt-serif-700italic - latin */
@font-face {
	font-display: swap;
	font-family: "PT Serif";
	font-style: italic;
	font-weight: 700;
	src: local("PT Serif Bold Italic"), local("PTSerif-BoldItalic"), url("https://gomakethings.com/fonts/pt-serif-v11-latin-700italic.woff2") format("woff2"), url("https://gomakethings.com/fonts/pt-serif-v11-latin-700italic.woff") format("woff");
}
/* pt-sans-regular - latin */
@font-face {
	font-display: swap;
	font-family: "PT Sans";
	font-style: normal;
	font-weight: 400;
	src: local("PT Sans"), local("PTSerif-Regular"), url("https://gomakethings.com/fonts/pt-sans-v12-latin-regular.woff2") format("woff2"), url("https://gomakethings.com/fonts/pt-sans-v12-latin-regular.woff") format("woff");
}
/* pt-sans-italic - latin */
@font-face {
	font-display: swap;
	font-family: "PT Sans";
	font-style: italic;
	font-weight: 400;
	src: local("PT Sans Italic"), local("PTSerif-Italic"), url("https://gomakethings.com/fonts/pt-sans-v12-latin-italic.woff2") format("woff2"), url("https://gomakethings.com/fonts/pt-sans-v12-latin-italic.woff") format("woff");
}
/* pt-sans-700 - latin */
@font-face {
	font-display: swap;
	font-family: "PT Sans";
	font-style: normal;
	font-weight: 700;
	src: local("PT Sans Bold"), local("PTSerif-Bold"), url("https://gomakethings.com/fonts/pt-sans-v12-latin-700.woff2") format("woff2"), url("https://gomakethings.com/fonts/pt-sans-v12-latin-700.woff") format("woff");
}
/* pt-sans-700italic - latin */
@font-face {
	font-display: swap;
	font-family: "PT Sans";
	font-style: italic;
	font-weight: 700;
	src: local("PT Sans Bold Italic"), local("PTSerif-BoldItalic"), url("https://gomakethings.com/fonts/pt-sans-v12-latin-700italic.woff2") format("woff2"), url("https://gomakethings.com/fonts/pt-sans-v12-latin-700italic.woff") format("woff");
}
			/*! gmt-theme v2.7.0 | (c) 2021 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/gmt-theme */
﻿a,button,input,select,textarea,label,summary{touch-action:manipulation}*,*:before,*:after{box-sizing:border-box}html{overflow-y:scroll;text-size-adjust:100%}body{margin:0;min-height:100vh}img,video{max-width:100%;height:auto}iframe,object,embed{max-width:100%}audio{width:100%}[tabindex="-1"]:focus{outline:none}.container{margin-left:auto;margin-right:auto;max-width:38em;width:88%}.container-large{max-width:60em}@media(min-width: 38em){.row{display:flex;margin-left:-1.4%;margin-right:-1.4%;justify-content:space-between}.row-reverse{flex-direction:row-reverse}.grid-auto,.grid-fourth,.grid-third,.grid-two-thirds,.grid-half,.grid-three-fourths{margin-left:1.4%;margin-right:1.4%}.grid-auto{flex:1 1}.grid-fifth{width:20%}.grid-fourth{width:25%}.grid-third{width:33.33333%}.grid-two-thirds{width:66.66666%}.grid-half{width:50%}.grid-three-fourths{width:75%}.grid-four-fifths{width:80%}}@media(min-width: 38em){.list-columns{column-count:2}}html{scroll-behavior:smooth}body{background:#fff;border-top:.5em solid #e5e5e5;color:#272727;font-family:"PT Sans",sans-serif;font-size:112.5%;line-height:1.5}@media(min-width: 38em){body{line-height:1.5625em}}@media(prefers-color-scheme: dark){body{background:#1f252f;border-top-color:gray;color:#fff}}p{margin:0 0 1.5625em}a{color:#08c;text-decoration-skip-ink:auto;word-wrap:break-word}a:active,a:focus,a:hover{color:#005580}main a:not(.btn):visited{color:purple}@media(prefers-color-scheme: dark){a{color:#73cffa}a:active,a:focus,a:hover{color:#29b6f7}main a:not(.btn):visited{color:#debfde}}.link-no-underline,.nav-secondary a{text-decoration:none}.link-no-underline:active,.nav-secondary a:active,.link-no-underline:focus,.nav-secondary a:focus,.link-no-underline:hover,.nav-secondary a:hover{text-decoration:underline}.link-plain,.link-plain:visited{color:#272727;text-decoration:none}@media(prefers-color-scheme: dark){.link-plain,.link-plain:visited{color:#fff}}.link-plain:active,.link-plain:focus,.link-plain:hover{color:#08c}@media(prefers-color-scheme: dark){.link-plain:active,.link-plain:focus,.link-plain:hover{color:#73cffa}}ul,ol{margin:0 0 1.5625em 2em;padding:0}ul ul,ul ol,ol ol,ol ul{margin-bottom:0}li{margin-bottom:.5em}@media(min-width: 38em){li{margin-bottom:.25em}}.list-spaced li{margin-bottom:1.5625em}@media(min-width: 38em){.list-spaced li{margin-bottom:1em}}.list-spaced-small li{margin-bottom:1.125em}@media(min-width: 38em){.list-spaced-small li{margin-bottom:.6875em}}dl,dd{margin:0;padding:0}dd{margin-bottom:1.5625em}dt{font-weight:bold}.list-inline,.nav,.list-unstyled{list-style:none;margin-left:0}.list-inline>li::before,.nav>li::before,.list-unstyled>li::before{content:"​";position:absolute}.list-unstyled{margin-left:0}.list-inline,.nav{margin-left:-0.5em;margin-right:-0.5em;padding:0}.list-inline>li,.nav>li{display:inline-block;margin-left:.5em;margin-right:.5em}@media(max-width: 38em){.list-inline.list-inline-responsive>li,.list-inline-responsive.nav>li{display:block}}.list-inline-spaced{margin-left:-1.3125em;margin-right:-1.3125em}.list-inline-spaced>li{margin-left:1.3125em;margin-right:1.3125em}.list-inline-compact{margin-left:-0.25em;margin-right:-0.25em}.list-inline-compact li{margin-left:.25em;margin-right:.25em}h1,h2,h3,h4,h5,h6{font-family:"PT Serif",sans-serif;line-height:1.2;margin:0 0 1em;padding:1em 0 0;word-wrap:break-word}h1,.h1{font-size:1.5em;padding-top:.5em}@media(min-width: 38em){h1,.h1{font-size:1.75em}}h2,.h2{font-size:1.3125em}h3,.h3{font-size:1.1875em}h4,h5,h6,.h4,.h5,.h6{font-size:1em}h4,.h4{font-size:.8125em;text-transform:uppercase}hr{border:0;border-top:1px solid #e5e5e5;margin:2em auto}@media(prefers-color-scheme: dark){hr{border-top-color:gray}}.line-secondary{width:50%}.line-clear{border-top-color:transparent}.line-overlay{margin-top:-2.8em}.line-overlay>strong{background-color:#fff;display:inline-block;padding:0 1em}@media(min-width: 38em){.line-overlay>strong{padding:0 2em}}@media(prefers-color-scheme: dark){.line-overlay>strong{background-color:#1f252f}}mark{background:#fbf9c9;color:#272727}@media(prefers-color-scheme: dark){mark{background:transparent;color:#fff}}blockquote{border-left:.25em solid #e5e5e5;font-style:italic;margin:0 0 1.5625em;padding-left:1em;padding-right:1em}blockquote pre{font-style:normal}cite{color:gray;display:block;font-size:.9375em;padding-top:1em}@media(prefers-color-scheme: dark){cite{color:#e5e5e5}}code,kbd,pre,samp{font-family:Menlo,Monaco,"Courier New",monospace;font-size:.875em}code{color:#d14;word-wrap:break-word}@media(prefers-color-scheme: dark){code{color:#ded7d9}}pre{background-color:#f7f7f7;display:block;line-height:1.5;margin:0 0 1.5625em;overflow:auto;padding:.8125em;tab-size:2;white-space:pre-wrap;word-break:break-all}@media(min-width: 38em){pre{tab-size:4}}@media(prefers-color-scheme: dark){pre{background-color:#343d4d}}pre code{color:inherit;font-size:1em}@media screen{.chroma .err,.chroma .kc,.chroma .no,.chroma .py,.chroma .nt,.chroma .ss,.chroma .m,.chroma .mb,.chroma .mf,.chroma .mh,.chroma .mi,.chroma .il,.chroma .mo{color:#905}}@media screen and (prefers-color-scheme: dark){.chroma .err,.chroma .kc,.chroma .no,.chroma .py,.chroma .nt,.chroma .ss,.chroma .m,.chroma .mb,.chroma .mf,.chroma .mh,.chroma .mi,.chroma .il,.chroma .mo{color:#cfcfcf}}@media screen{.chroma .k,.chroma .kd,.chroma .kn,.chroma .kp,.chroma .kr,.chroma .kt,.chroma .nb,.chroma .s{color:#07a}}@media screen and (prefers-color-scheme: dark){.chroma .k,.chroma .kd,.chroma .kn,.chroma .kp,.chroma .kr,.chroma .kt,.chroma .nb,.chroma .s{color:#95dbfb}}@media screen{.chroma .n,.chroma .na,.chroma .nc,.chroma .ne,.chroma .l,.chroma .ld,.chroma .sa,.chroma .sb,.chroma .sc,.chroma .dl,.chroma .s1,.chroma .s2,.chroma .se,.chroma .sh,.chroma .si,.chroma .sx{color:#690}}@media screen and (prefers-color-scheme: dark){.chroma .n,.chroma .na,.chroma .nc,.chroma .ne,.chroma .l,.chroma .ld,.chroma .sa,.chroma .sb,.chroma .sc,.chroma .dl,.chroma .s1,.chroma .s2,.chroma .se,.chroma .sh,.chroma .si,.chroma .sx{color:#c5d99c}}@media screen{.chroma .bp,.chroma .nd,.chroma .nl,.chroma .sd,.chroma .p,.chroma .c,.chroma .ch,.chroma .cm,.chroma .c1,.chroma .cs,.chroma .cp,.chroma .cpf{color:#708090}}@media screen and (prefers-color-scheme: dark){.chroma .bp,.chroma .nd,.chroma .nl,.chroma .sd,.chroma .p,.chroma .c,.chroma .ch,.chroma .cm,.chroma .c1,.chroma .cs,.chroma .cp,.chroma .cpf{color:#e5e5e5}}@media screen{.chroma .ni,.chroma .o{color:#a67f59;background:rgba(255,255,255,.5)}}@media screen and (prefers-color-scheme: dark){.chroma .ni,.chroma .o{background:transparent;color:#e5e5e5}}@media screen{.chroma .nf,.chroma .fm,.chroma .ow{color:#dd4a68}}@media screen and (prefers-color-scheme: dark){.chroma .nf,.chroma .fm,.chroma .ow{color:#deb6be}}@media screen{.chroma .nv,.chroma .vc,.chroma .vg,.chroma .vi,.chroma .vm,.chroma .sr{color:#e90}}@media screen and (prefers-color-scheme: dark){.chroma .nv,.chroma .vc,.chroma .vg,.chroma .vi,.chroma .vm,.chroma .sr{color:#ede1ca}}@media screen{.chroma .nn{opacity:.7}}@media screen{.chroma .ge{font-style:italic}}@media screen{.chroma .gs{font-weight:bold}}.btn{background-color:#f7272f;border:.125em solid #f7272f;display:inline-block;font-size:.9375em;font-weight:normal;line-height:1.2;margin-right:.3125em;margin-bottom:.3125em;padding:.5em .6875em}.btn,.btn:focus{color:#fff}@media(prefers-color-scheme: dark){.btn,.btn:focus{background-color:#fdd4d5;border-color:#fdd4d5;color:#000}}.btn:hover,.btn:active{background-color:#cb070e;border-color:#cb070e;color:#fff}@media(prefers-color-scheme: dark){.btn:hover,.btn:active{background-color:#fdbbbd;border-color:#fdbbbd;color:#000}}a.btn{text-decoration:none}.btn-secondary{background-color:#343d4d;border-color:#343d4d}@media(prefers-color-scheme: dark){.btn-secondary{background-color:#d2d7e1;border-color:#d2d7e1;color:#000}}.btn-secondary:hover,.btn-secondary:active,.btn-secondary.active{background-color:#15191f;border-color:#15191f}@media(prefers-color-scheme: dark){.btn-secondary:hover,.btn-secondary:active,.btn-secondary.active{background-color:#c3cad6;border-color:#c3cad6;color:#000}}.btn-tertiary{background-color:#08c;border-color:#08c}@media(prefers-color-scheme: dark){.btn-tertiary{background-color:#cef;border-color:#cef;color:#000}}.btn-tertiary:hover,.btn-tertiary:active,.btn-tertiary.active{background-color:#005580;border-color:#005580}@media(prefers-color-scheme: dark){.btn-tertiary:hover,.btn-tertiary:active,.btn-tertiary.active{background-color:#b3e6ff;border-color:#b3e6ff;color:#000}}.btn:active{box-shadow:inset 0 .15625em .25em rgba(0,0,0,.15),0 1px .15625em rgba(0,0,0,.05);outline:0}.btn[disabled],[data-submitting] .btn{box-shadow:none;cursor:not-allowed;opacity:.5;pointer-events:none}.btn-large{font-size:1em;line-height:normal;padding:.6875em .9375em}.btn-block{display:block;margin-right:0;padding-right:0;padding-left:0;width:100%}.btn,button,html input[type=button],input[type=reset],input[type=submit]{cursor:pointer;text-align:center;vertical-align:middle}.btn:last-child,input.btn{margin-right:0}form,fieldset{margin-bottom:1.5625em}fieldset{border:0;padding:0}legend,label{display:block;margin:0 0 .3125em;padding:0}button,input,optgroup,select,textarea{color:#555;font:inherit;margin:0;padding:.3125em}@media(prefers-color-scheme: dark){button,input,optgroup,select,textarea{background-color:#e5e5e5;color:#272727}}input,textarea,select{border:1px solid #b8b8b8;display:block;line-height:1.5;margin-bottom:1.1875em;width:100%}@media(min-width: 38em){input,textarea,select{line-height:1.5625}}@media(prefers-color-scheme: dark){input,textarea,select{border-color:gray}}form button,form .btn{margin-bottom:1.1875em}textarea{height:8em;overflow:auto;resize:vertical}[type=image],[type=checkbox],[type=radio]{cursor:pointer;display:inline-block;height:auto;margin-bottom:.3125em;padding:0;width:auto}[type=checkbox],[type=radio]{margin-right:.25em}input:focus,textarea:focus{border-color:rgba(82,168,236,.8)}.input-inline{display:inline-block;vertical-align:middle;width:auto}.input-condensed{line-height:1;padding-top:.125em;padding-bottom:.125em;vertical-align:top}.input-search{width:85%;padding-left:.9375em;padding-right:2.5em;border-radius:1.3125em;transition:width 300ms ease-in}@media(min-width: 38em){.input-search{width:65%}}.btn-search{display:inline;color:gray;border:none;background:none;margin-left:-2.5em;margin-bottom:0}.btn-search:hover{color:#5a5a5a}.error{border-color:#e30810}@media(prefers-color-scheme: dark){.error{border-color:#fdbbbd}}.success-message,.error-message{font-style:italic}.error-message{color:#e30810;margin-bottom:1em}@media(prefers-color-scheme: dark){.error-message{color:#fdbbbd}}figure{margin:0 0 1.5625em;padding:0}figcaption{font-size:.9375em;font-style:italic;color:gray;padding-top:.5em;text-align:center}@media(prefers-color-scheme: dark){figcaption{color:#e5e5e5}}.img-border{border:1px solid #ccc}.img-circle{border-radius:50%}.img-center,.img-left{display:block;text-align:center;margin-left:auto;margin-right:auto}@media(min-width: 28em){.img-left{float:left;margin-right:1em}}@media(prefers-color-scheme: dark){svg path[fill="#272727"]{fill:#fff}svg path[fill="#808080"]{fill:#e5e5e5}svg path[fill="#f7272f"]{fill:#fdd4d5}svg path[fill="#800080"]{fill:#ff4dff}svg path[fill="#ffffff"]{fill:#1f252f}.company-logo path{fill:#fff}}iframe{aspect-ratio:16/9;height:100%;margin-bottom:1.5625em;width:100%}.callout{background-color:#f7f7f7;border:1px solid #e5e5e5;margin-bottom:1.5625em;padding:1em 1.5em}@media(prefers-color-scheme: dark){.callout{background-color:#171b22;border-color:gray}}.tarpit{display:none}table{border-collapse:collapse;border-spacing:0;margin-bottom:1.5625em;max-width:100%;width:100%}th,td{text-align:left;padding:.5em}th{border-bottom:.125em solid #e5e5e5;font-weight:bold;vertical-align:bottom}td{border-top:1px solid #e5e5e5;vertical-align:top}.table-striped tbody tr:nth-child(odd){background-color:#f7f7f7}.nav-wrap{padding-top:1em;padding-bottom:.5em;text-align:center}@media(min-width: 60em){.nav-wrap{display:flex;justify-content:space-between}}.logo{display:inline-block;font-family:"PT Serif",sans-serif;font-size:1.2em;font-weight:bold;line-height:1.2;margin-bottom:.3125em;text-decoration:none}@media(min-width: 60em){.logo{margin-bottom:0}}.logo,.logo:focus{color:#272727}@media(prefers-color-scheme: dark){.logo,.logo:focus{color:#fff}}.logo:active,.logo:hover{color:#08c}@media(prefers-color-scheme: dark){.logo:active,.logo:hover{color:#73cffa}}.nav{margin-bottom:0}.nav a{color:gray;text-decoration:none}@media(prefers-color-scheme: dark){.nav a{color:#e5e5e5}}.nav a:hover,.nav a:active,.nav a:focus,.nav .active a,.nav [aria-current=page]{border-bottom:.125em solid #fa7176;color:#272727}@media(prefers-color-scheme: dark){.nav a:hover,.nav a:active,.nav a:focus,.nav .active a,.nav [aria-current=page]{color:#fff}}.text-small{font-size:.9375em}.text-large,.text-xlarge{font-size:1.1875em;line-height:1.4}@media(min-width: 38em){.text-large,.text-xlarge{font-size:1.3125em}}.text-xlarge{font-size:1.7em}@media(min-width: 38em){.text-xlarge{font-size:2em}}.text-muted{color:gray}@media(prefers-color-scheme: dark){.text-muted{color:#e5e5e5}}.text-muted-light,.btn del{color:#b2b2b2}.text-normal{font-weight:normal;font-style:normal}.text-capitalize{text-transform:capitalize}.text-sans{font-family:"PT Sans",sans-serif}.text-serif{font-family:"PT Serif",sans-serif}.text-center{text-align:center}.text-right{text-align:right}@media(min-width: 38em){.text-right-large{text-align:right}}.no-margin-top{margin-top:0}.no-margin-bottom{margin-bottom:0}.margin-top{margin-top:1.5625em}.margin-bottom,audio{margin-bottom:1.5625em}.margin-bottom-small{margin-bottom:.5em}.margin-bottom-medium{margin-bottom:1.1875em}.margin-bottom-large{margin-bottom:2em}.margin-bottom-negative{margin-bottom:-1.75em}.margin-right{margin-right:.25em}.no-padding-top{padding-top:0}.no-padding-bottom{padding-bottom:0}.padding-top{padding-top:1.5625em}.padding-top-xsmall{padding-top:.25em}.padding-top-small{padding-top:.5em}.padding-top-medium{padding-top:1em}.padding-top-large{padding-top:2em}.padding-top-xlarge{padding-top:3em}.padding-bottom{padding-bottom:1.5625em}.padding-bottom-small{padding-bottom:.5em}.padding-bottom-large{padding-bottom:2em}.padding-bottom-xlarge{padding-bottom:3em}.screen-reader{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.screen-reader-focusable:active,.screen-reader-focusable:focus{clip:auto;height:auto;margin:0;overflow:visible;position:static;white-space:inherit;width:auto}@media(prefers-reduced-motion: reduce){*{animation-duration:.01ms !important;animation-iteration-count:1 !important;transition-duration:.01ms !important;scroll-behavior:auto !important}}.clearfix:before,.container:before,.clearfix:after,.container:after{display:table;content:" "}.clearfix:after,.container:after{clear:both}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}@page{margin:.5cm}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}a[href^="#"]:after{content:""}p,h1,h2,h3{orphans:3;widows:3}h1,h2,h3{page-break-after:avoid}pre,blockquote{border-color:#999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}header .nav,footer,main aside form{display:none}body{border-top:none}}
		</style>
	</head>

	<body class="type-search page-single" id="page-4953bf99d7018c161b1b361cb25f1331">

		<div class="container container-large">

	
	<a class="screen-reader screen-reader-focusable" href="#main">Skip to main content</a>

	
	<a class="screen-reader screen-reader-focusable" href="mailto:&#099;&#104;&#114;&#105;&#115;&#064;&#103;&#111;&#109;&#097;&#107;&#101;&#116;&#104;&#105;&#110;&#103;&#115;&#046;&#099;&#111;&#109;?subject=Go%20Make%20Things:%20Accessibility%20Feedback">Accessibility Feedback</a>

</div>

		<header class="container container-large margin-bottom-large">
	<nav class="nav-wrap">
		<a class="logo" href="https://reefjs.com">
			<svg xmlns="http://www.w3.org/2000/svg" width="0.674698795em" height="1em" style="height:.8em;width:0.539759036em;" viewBox="0 0 56 83"><title></title><path fill="currentColor" fill-rule="nonzero" d="M5.159 46.847c-.87.147-1.676.218-2.394.208a2.716 2.716 0 00-1.938.774A2.71 2.71 0 000 49.749a2.73 2.73 0 002.693 2.764c2.181.031 4.337-.326 6.589-1.09a1.508 1.508 0 011.548.35c2.174 2.126 4.632 3.68 7.012 5.185 5.553 3.517 9.938 6.291 10.286 14.545l-.006 1.038c-.02 2.131-.064 7.063.081 10.11h5.463l-.001-.104a86.437 86.437 0 01-.078-6.825l.004-.03-.004-.098c.076-5.533 4.852-8.295 9.51-10.265 4.494-1.899 8.648-5.25 9.922-7.266.01-.01.014-.02.021-.026 1.252-1.895 2.09-4.082 2.564-6.687a2.69 2.69 0 00-.443-2.041 2.707 2.707 0 00-1.756-1.133 2.713 2.713 0 00-2.043.443 2.715 2.715 0 00-1.131 1.755c-1.127 6.224-4.793 7.889-9.432 10-.787.358-1.678.763-2.561 1.206a1.523 1.523 0 01-1.662-.199 1.519 1.519 0 01-.467-1.605c1.113-3.586 2.5-6.823 3.842-9.953 3.748-8.734 7.623-17.767 6.725-35.157a2.729 2.729 0 00-2.865-2.584c-.729.036-1.4.354-1.887.897a2.716 2.716 0 00-.697 1.969c.254 4.921.121 9.304-.404 13.396a1.523 1.523 0 01-1.133 1.276 1.526 1.526 0 01-1.604-.581c-.695-.96-1.475-1.925-2.523-3.129a2.696 2.696 0 00-1.871-.93 2.705 2.705 0 00-1.98.666 2.735 2.735 0 00-.264 3.851c3.781 4.33 6.949 9.213 4.584 15.549-.014.041-.014.041-.703 1.678l-1.578 3.739a1.519 1.519 0 01-2.85-.135c-1.972-6.355-4.658-11.178-7.256-15.837-1.495-2.683-3.044-5.457-4.408-8.492a1.54 1.54 0 01-.009-1.222c1.072-2.495 2.82-4.696 4.675-7.026 1.79-2.252 3.641-4.58 5.002-7.376l.028-.067a2.724 2.724 0 00-2.443-3.92 2.737 2.737 0 00-2.456 1.548l-.004.011c-.007.014-.012.026-.02.039-1.057 2.187-2.598 4.125-4.382 6.37l-1.267 1.608a1.53 1.53 0 01-1.53.545 1.51 1.51 0 01-1.147-1.139c-.879-3.88-1.424-8.062-1.667-12.781a2.709 2.709 0 00-.9-1.887 2.7 2.7 0 00-1.968-.697A2.7 2.7 0 009.263.9a2.711 2.711 0 00-.697 1.969c.075 1.483.183 2.959.324 4.387a1.519 1.519 0 01-1.587 1.662 13.7 13.7 0 01-3.639-.667A2.737 2.737 0 00.207 9.973a2.735 2.735 0 001.723 3.455c2.095.702 4.284 1.018 6.695.966a1.512 1.512 0 011.515 1.205c1.976 9.423 5.414 15.588 8.736 21.547 2.63 4.721 5.116 9.179 6.958 15.306a1.517 1.517 0 01-2.307 1.689 98.616 98.616 0 00-2.768-1.795c-4.359-2.762-8.127-5.148-9.616-10.262a21.265 21.265 0 01-.582-1.868 2.731 2.731 0 00-3.341-1.933 2.714 2.714 0 00-1.658 1.271 2.7 2.7 0 00-.274 2.07c.352 1.316.674 2.317 1.018 3.15.175.428.147.908-.073 1.313a1.516 1.516 0 01-1.074.76z"/></svg>
			Reef
		</a>
		<div class="nav-menu" id="nav-menu">
			<ul class="nav">
				<li><a href="https://reefjs.com/getting-started">Getting Started</a></li><li><a href="https://reefjs.com/state-management">State Management</a></li><li><a href="https://reefjs.com/advanced">Advanced</a></li><li><a href="https://reefjs.com/api">API Reference</a></li></li><li><a href="https://reefjs.com/demos">Demos</a></li></li><li><a href="https://reefjs.com/about">v11.x</a></li>
			</ul>
		</div>
	</nav>
</header>

		<main id="main" tabindex="-1">

			<div class="container">

	<article>

	
	<h1>Search</h1>
	

	<form action="https://www.google.com/search?q=site%3Agomakethings.com&oq=site%3Agomakethings.com" id="form-search">
	<label class="screen-reader" for="input-search">Enter your search criteria:</label>
	<input type="text" name="q" class="input-search input-inline no-margin-bottom" id="input-search"autofocus placeholder='Search this site...' value=" site:gomakethings.com">
	<button type="submit" class="btn-search" id="submit-search">
		<svg xmlns="http://www.w3.org/2000/svg" style="height: 1em; width: 1em;" viewBox="0 0 32 32" aria-labelledby="search-title"><title id="search-title">Search</title><path fill="currentColor" d="M31.008 27.23l-7.58-6.446c-.784-.705-1.622-1.03-2.3-.998C22.92 17.69 24 14.97 24 12 24 5.37 18.627 0 12 0S0 5.37 0 12c0 6.626 5.374 12 12 12 2.973 0 5.692-1.082 7.788-2.87-.03.676.293 1.514.998 2.298l6.447 7.58c1.105 1.226 2.908 1.33 4.008.23s.997-2.903-.23-4.007zM12 20c-4.418 0-8-3.582-8-8s3.582-8 8-8 8 3.582 8 8-3.582 8-8 8z"/></svg>
	</button>
</form>

<div id="search-results"></div>


</article><script>
		var searchIndex = JSON.parse("[{\"content\":\" Reef provides various options, methods, and custom events that you can hook into.\\n Global Methods Run these methods directly on the Reef object.\\nReef.debug() Turn debug mode on or off. Pass in true to turn debug mode on, and false to turn it off.\\n// Turn debug mode on Reef.debug(true); // Turn debug mode off Reef.debug(false);  Component Properties Access these properties on individual Reef components.\\nReef.prototype.data Get a reactive copy of the app data.\\nlet data = app.data;  Reef.prototype.dataCopy Get a non-reactive, immutable copy of the app data.\\nlet copy = app.dataCopy; // This will not update the component data or cause a render copy.todos.push(\\u0026#39;Zzzz... take a nap!\\u0026#39;);  Reef.prototype.elem The element the component is associated with. Returns a string or Node.\\nlet elem = app.elem;  Component Methods Run these methods on individual Reef components.\\nReef.prototype.render() Render a Reef component in the UI.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;Hello world!\\u0026#39;; } }); app.render();  Reef.prototype.html() Get the compiled HTML string for a component. Used for nesting components.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;Hello world!\\u0026#39;; } }); app.html();  Reef.prototype.do() Run a setter function. Pass in the name of the setter, and a comma-separate list of any arguments.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { count: 0 }, template: function (props) { return count; }, setters: { increase: function (props) { props.count++; } } }); // Run the increase setter app.do(\\u0026#39;increase\\u0026#39;);  Events Reef emits custom events throughout the lifecycle of a component or instance.\\nAll Reef events follow a reef:{event-name} pattern. Unless otherwise specified, all events are emitted on the document element. Event details can be accessed on the event.detail property.\\n// Listen for when Reef components are rendered into the DOM document.addEventListener(\\u0026#39;reef:render\\u0026#39;, function (event) { console.log(event.target); // The element it was rendered into \\tconsole.log(event.detail); // The component, and the data used for the render });   reef:ready is emitted when Reef is loaded into the DOM and ready to use. reef:initialized is emitted when a new Reef component is initialized.  event.detail - the instance  reef:before-render is emitted on an element before a new UI is rendered into it.  event.target - the element the component is being rendered into event.detail - the component and the data at time of render event.preventDefault() - stop the component from rendering  reef:render is emitted on an element after a new UI is rendered into it.  event.target - the element the component was rendered into event.detail - the component and the data that was used for the render   Options All of the options for Reef.\\n// This can be a string or a element let elem = \\u0026#39;#app\\u0026#39;; new Reef(elem, { // The component data \\tdata: {}, // A data store to use \\t// If used, the data option is ignored \\tstore: null, // An object of setter methods \\tsetters: {}, // An object of allowed event listeners \\tlisteners: {} }); \",\"title\":\"API Reference\",\"type\":\"page\",\"url\":\"https://reefjs.com/api/\"},{\"content\":\"  Browser Compatibility Reef works in all modern browsers. That means:\\n The latest versions of Edge, Chrome, Firefox, and Safari. Mobile Safari, Chrome, and Firefox on Safari. WebView, Chrome, and Firefox for Android.  If you need to support older browsers, you\\u0026rsquo;ll need to transpile your code into ES5 with BabelJS.\\nLicense The code is available under the MIT License.\\nChangelog You can find all available versions under releases.\\nVersion 11 (current version) improves the developer experience.\\n Removed getters (which were causing confusion). Removed Reef.clone(), Reef.emit(), and Reef.err() methods. Updated nested components for easier use. Added ability to attach event listeners directly to elements in templates. Updated dynamic and default form values to use @ and # for better ergonomics.  Version 10 brings more layout control.\\n Template data is allowed to contain HTML by default. The sanitization engine has been updated to be more robust. on* attributes are no longer allowed on elements. Components can now use both a shared store and local data.  Version 9 reduces under-the-hood complexity.\\n Large refactor to reduce abstractions for improved performance and reduced file size. Removed all router options.  Version 8 brings more predictability and convenience when building interactive UIs.\\n Added reef-checked, reef-selected, and reef-value attributes (and reef-default-* versions) for more predictable form field behavior. Added new helper methods for more accurate type checking and throwing errors. Improved DOM diffing under-the-hood. Fixed router issues with module bundlers. Improved control for route titles. Dropped legacy browser support.  Version 7 introduces new tools for managing more complex applications.\\n Added new Reef.Store() data store constructor for reactive shared state. Added getter and setter functions for more fine-grained control over how data flows in and out of components. Improved process for attaching nested components to parent components. Removed the clone() method on individual components (the global Reef.clone() method still exists).  Version 6 completely changes how data reactivity works.\\n Component data is now directly reactive. The setData() and getData() methods (previously used for reactivity) have been removed. You can get an immutable copy of your data with the clone() method. Added an emit() method for emitting custom events. IE support now requires polyfills or transpiling.  Version 5 adds new build system and filename structure,\\n Specific named versions for ES modules, AMD, and CommonJS. Default build is browser-only. ES modules now natively supported.  Version 4 adds better performance and XSS protection.\\n Data is once again automatically encoded to help protect you from cross-site scripting (XSS) attacks. Changes to diffing and rendering reduce reflows and improve performance. Support pushed back even further to IE9. Deprecated: Custom sanitizer methods were removed in favor of built-in, automated HTML encoding. You can still add custom sanitization within template functions.  Version 3 removes built-in sanitization.\\n Automatic sanitization has been removed. HTML templates are unsanitized by default. Two new hooks to add sanitization to your components have been added. This provides more developer flexibility and keeps Reef as lightweight as possible.  Version 2 adds a better sanitizing engine and markup support.\\n DOMPurify is now the template sanitizing engine. The attribute exceptions feature has been removed in favor of DOMPurify\\u0026rsquo;s configuration options. The addAttributes() and removeAttributes() methods no longer exist. Reef now offers a smaller unsafe version for UIs that don\\u0026rsquo;t use any third-party or user-provided content. It does not sanitize templates before rendering, so use with caution. SVGs are now properly supported and will render correctly.  Version 1 removed polyfill dependencies.\\n All polyfills have been removed and are no longer needed. This is a breaking change, as the .polyfill versions of scripts no longer exist.  Version 0.2 introduced some big new features.\\n Data reactivity and automatically updating UI Support for nested components Shared state support (with data reactivity!) Custom attribute exceptions for your templates  Hi, I'm Chris Ferdinandi. 👋 I believe there’s a simpler, more resilient way to make things for the web.\\nI create vanilla JS pocket guides and video courses, run a project-based training program, and host the vanilla JS podcast. My developer tips newsletter is read by over {{mc_subs}} developers each weekday.\\nIf you have a question about something or need JavaScript help, get in touch.\\n Get Daily Developer Tips **Sick of over-engineered modern web developer \\\"best practices?\\\"** I send out a short email each weekday on how to build a simpler, more resilient web. Join 12,700+ others.\\nIf you're human, leave this blank  Enter your email address to get Daily Developer Tips emails  Get Daily Developer Tips     \",\"title\":\"About\",\"type\":\"page\",\"url\":\"https://reefjs.com/about/\"},{\"content\":\" As your project gets bigger, the way you manage components and data may need to grow with it. Reef has some options to help make things a little easier.\\n HTML Templates Default and state-based HTML attributes You can use component data to conditionally include or change the value of HTML attributes in your template.\\nTo dynamically set checked, selected, and value attributes, prefix them with an @ symbol. Use a falsy value when the item should not be checked or selected.\\nIn the example below, the checkbox is checked when agreeToTOS is true.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { agreeToTOS: true }, template: function (props) { return ` \\u0026lt;label\\u0026gt; \\u0026lt;input type=\\u0026#34;checkbox\\u0026#34; @checked=\\u0026#34;${agreeToTOS}\\u0026#34;\\u0026gt; \\u0026lt;/label\\u0026gt;`; } });  You might instead want to use a default value when an element initially renders, but defer to any changes the user makes after that.\\nYou can do that by prefixing your attributes with a # symbol.\\nIn this example, Hermione has the [selected] attribute on it when first rendered, but will defer to whatever changes the user makes when diffing and updating the UI.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return ` \\u0026lt;label for=\\u0026#34;wizards\\u0026#34;\\u0026gt;Who is the best wizard?\\u0026lt;/label\\u0026gt; \\u0026lt;select\\u0026gt; \\u0026lt;option\\u0026gt;Harry\\u0026lt;/option\\u0026gt; \\u0026lt;option #selected\\u0026gt;Hermione\\u0026lt;/option\\u0026gt; \\u0026lt;option\\u0026gt;Neville\\u0026lt;/option\\u0026gt; \\u0026lt;/select\\u0026gt;`; } });  Try controlling form attributes on CodePen \\u0026rarr;\\nPreventing Cross-Site Scripting (XSS) Attacks To reduce your risk of cross-site scripting (XSS) attacks, Reef automatically sanitizes the HTML from your template before rendering it.\\nIn the example below, the attempted XSS attack (the alert()) will not run. Safe HTML, like the bold in the greeting property, will be rendered as expected.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;\\u0026lt;strong\\u0026gt;Hello\\u0026lt;/strong\\u0026gt;\\u0026#39;, name: \\u0026#39;world\\u0026#39;, img: \\u0026#39;\\u0026lt;img src=\\u0026#34;x\\u0026#34; onerror=\\u0026#34;alert(1)\\u0026#34;\\u0026gt;\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt; ${props.img}`; } });  Try HTML sanitization on CodePen \\u0026rarr;\\nAttaching event listeners to elements To use event listeners in your templates, allowed callback functions need to be added to the listeners property on the component options object.\\nInside the callback function, this refers to the components and its properties. Reef uses event delegation under-the-hood for better performance, and automatically cleans up listeners when the elements they\\u0026rsquo;re attached to are removed.\\nAny on* callback function not included in the listeners object is removed to reduce the risk of XSS attacks.\\nnew Reef(\\u0026#39;#app\\u0026#39;, { data: { text: \\u0026#39;\\u0026#39; }, template: function (props) { return ` \\u0026lt;label for=\\u0026#34;mirror\\u0026#34;\\u0026gt;Whatever you type shows up below the field\\u0026lt;/label\\u0026gt; \\u0026lt;input type=\\u0026#34;text\\u0026#34; oninput=\\u0026#34;mirror()\\u0026#34; id=\\u0026#34;mirror\\u0026#34;\\u0026gt; \\u0026lt;div\\u0026gt;\\u0026lt;em aria-live=\\u0026#34;polite\\u0026#34;\\u0026gt;${props.text.length ? props.text : \\u0026#39;Type something above to change this text\\u0026#39;}\\u0026lt;/em\\u0026gt;\\u0026lt;/div\\u0026gt;`; }, listeners: { mirror: function (event) { this.data.text = event.target.value; } } }).render();  Try working with event listeners on CodePen \\u0026rarr;\\nGetting the element the template is being rendered into An optional second argument is passed into the template() function: the element that the template is being rendered into.\\nThis is particularly handy if you have data attributes on your element that affect what\\u0026rsquo;s rendered into the template.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34; data-greeting=\\u0026#34;Hello\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { name: \\u0026#39;world\\u0026#39; }, template: function (props, elem) { return `\\u0026lt;h1\\u0026gt;${elem.getAttribute(\\u0026#39;data-greeting\\u0026#39;)}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Try getting the HTML element that the template was rendered into on CodePen \\u0026rarr;\\nNested Components If you\\u0026rsquo;re managing a bigger app, you may have components nested inside other components.\\nYou can Reef components inside each other using the Reef.prototype.html() method in your template string. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\n// Parent component let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { heading: \\u0026#39;My Todos\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.heading}\\u0026lt;/h1\\u0026gt; \\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt; ${todos.html()}\\u0026lt;/div\\u0026gt;`; } }); // Nested component let todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: { todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, template: function (props) { return ` \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } }); // Render your app // todos will be automatically rendered because they\\u0026#39;re nested in the app component app.render();  Try nested components on CodePen \\u0026rarr;\\nShared State with Data Stores A Data Store is a special Reef object that holds reactive data you can share with multiple components.\\nAny time you update the data in your Data Store, any components that use the data will also be updated, and will render again if there are any UI changes.\\nCreate a Data Store using the new Reef.Store() constructor.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] } });  To use your Data Store with a component, pass it in with the store property instead of providing a data object.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { store: store, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.heading}\\u0026lt;/h1\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } });  When using a Data Store, your component can still have its own local data as well.\\nThe local component data is merged into the store and passed into the template() function as a single props object.\\nlet store = new Reef.Store({ data: { todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] } }); let app = new Reef(\\u0026#39;#app\\u0026#39;, { store: store, data: { heading: \\u0026#39;My Todos\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.heading}\\u0026lt;/h1\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } });  Try creating a Data Store on CodePen \\u0026rarr;\\nNote: if any properties in your store and data that share the same name, the local component data gets priority.\\nSetter Functions Reef\\u0026rsquo;s reactive data makes updating your UI as simple as updating an object property.\\nBut as your app scales, you may find that keeping track of what\\u0026rsquo;s updating state and causing changes to the UI becomes harder to track and maintain.\\nSetter functions provide you with a way to control how data flows in and out of your component.\\nAdd your setter functions to the setters property on your options object. The first parameter on a setter function must be the store or component data. You can add as many other parameters as you\\u0026rsquo;d like.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, setters: { // Add a new todo item to the component \\taddTodo: function (props, todo) { props.todos.push(todo); } } });  Use setter functions by calling the do() method on your component or store. Pass in the name of the setter, along with any required arguments (except for props).\\n// Add a new todo item store.do(\\u0026#39;addTodo\\u0026#39;, \\u0026#39;Take a nap... zzzz\\u0026#39;);  When a component or store has setter functions, they become the only way to update app or store data.\\nThis protects your component or store data from unwanted changes. The data property always returns an immutable copy.\\n// This will NOT update the store.data or the UI store.data.todos.push(\\u0026#39;Take a nap... zzzz\\u0026#39;);  Try working with setter functions on CodePen \\u0026rarr;\\nAsynchronous Data You can use asynchronous data (such as content from an API) in your templates.\\nSet an initial default value, make your API call, and update the data property once you get data back. This will automatically trigger a render.\\n// Create an app let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { articles: [] }, template: function (props) { // If there are no articles \\tif (!props.articles.length) { return `\\u0026lt;p\\u0026gt;There are no articles.\\u0026lt;/p\\u0026gt;`; } // Otherwise, show the articles \\treturn ` \\u0026lt;ul\\u0026gt; ${props.articles.map(function (article) { return `\\u0026lt;li\\u0026gt; \\u0026lt;strong\\u0026gt;\\u0026lt;a href=\\u0026#34;#\\u0026#34;\\u0026gt;${article.title}.\\u0026lt;/a\\u0026gt;\\u0026lt;/strong\\u0026gt; ${article.body}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } }); // Fetch API data // Then, update the app data fetch(\\u0026#39;https://jsonplaceholder.typicode.com/posts\\u0026#39;).then(function (response) { return response.json(); }).then(function (data) { app.data.articles = data; });  Try create a template from asynchronous data on CodePen \\u0026rarr;\\nYou might also choose to hard-code a loading message in your markup.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;Loading...\\u0026lt;/div\\u0026gt; Debugging By default, Reef fails silently. You can put Reef into debug mode to expose helpful error message in the Console tab of your browser\\u0026rsquo;s Developer Tools.\\nTurn debug mode on or off with the Reef.debug() method. Pass in true to turn it on, and false to turn it off.\\n// Turns debug mode on Reef.debug(true); // Turns debug mode off Reef.debug(false);  Get Daily Developer Tips **Sick of over-engineered modern web developer \\\"best practices?\\\"** I send out a short email each weekday on how to build a simpler, more resilient web. Join 12,700+ others.\\nIf you're human, leave this blank  Enter your email address to get Daily Developer Tips emails  Get Daily Developer Tips     \",\"title\":\"Advanced Components\",\"type\":\"page\",\"url\":\"https://reefjs.com/advanced/\"},{\"content\":\"Want to see Reef in action? Here are some demos and examples you can play with.\\n Clock Mirror Typing Pomodoro Timer Stopwatch Progress Bar Todo List Whack-a-Mole Game Articles from an API  Get Daily Developer Tips **Sick of over-engineered modern web developer \\\"best practices?\\\"** I send out a short email each weekday on how to build a simpler, more resilient web. Join 12,700+ others.\\nIf you're human, leave this blank  Enter your email address to get Daily Developer Tips emails  Get Daily Developer Tips     \",\"title\":\"Demos\",\"type\":\"page\",\"url\":\"https://reefjs.com/demos/\"},{\"content\":\" 1. Include Reef on your site Reef works without any build step.\\nThe CDN is the fastest and simplest way to get started, but you can use importable modules or a direct download if you\\u0026rsquo;d prefer.\\n\\u0026lt;!-- Get the latest major version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@11/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; Reef uses semantic versioning. You can grab a major, minor, or patch version from the CDN with the @1.2.3 syntax. You can find all available versions under releases.\\n More ways to install Reef ES Modules\\nReef also supports modern browsers and module bundlers (like Rollup, Webpack, Snowpack, and so on) using the ES modules import syntax. Use the .es version.\\nimport Reef from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@11/dist/reef.es.min.js\\u0026#39;;  NPM\\nYou can also use NPM (or your favorite package manager). First, install with NPM.\\nnpm install reefjs --save Then import the package.\\nimport Reef from \\u0026#39;reefjs\\u0026#39;;  CommonJS\\nIf you use NodeJS, you can import Reef using the require() method with the .cjs version.\\nlet Reef = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@11/dist/reef.cjs.min.js\\u0026#39;);  AMD\\nIf you use RequireJS, SystemJS, and other AMD formats, you can import Reef with the .amd version.\\nrequirejs([\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@11/dist/reef.amd.min.js\\u0026#39;], function (Reef) { //... });  Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\n2. Add an element to render your component/UI into This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works let app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too let elem = document.querySelector(\\u0026#39;#app\\u0026#39;); let app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, a function that returns an HTML string to render into the DOM.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  [Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nAn immutable copy of the data object is automatically passed into your template function, so that you can use it to customize your template.\\n// Some data let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Template literals give you a simple, JSX-like templating experience.\\n4. Render your component Render your component by calling the render() method on it.\\napp.render();  Try the demo on CodePen \\u0026rarr;\\nGet Daily Developer Tips **Sick of over-engineered modern web developer \\\"best practices?\\\"** I send out a short email each weekday on how to build a simpler, more resilient web. Join 12,700+ others.\\nIf you're human, leave this blank  Enter your email address to get Daily Developer Tips emails  Get Daily Developer Tips     \",\"title\":\"Getting Started\",\"type\":\"page\",\"url\":\"https://reefjs.com/getting-started/\"},{\"content\":\" A lightweight helper function for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features:\\n Weighs under 2kb (minified and gzipped), with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a simple \\u0026lt;script\\u0026gt; tag\\u0026mdash;no command line or transpiling required. Updates only the parts of the DOM that have changed. Keep those form fields in focus! Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Supported all the way back to IE10.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef sanitizes your data before rendering to minimize the risk of XSS scripting attacks. It also only updates things that have changed instead clobbering the DOM and removing focus from your form fields.\\nIf you\\u0026rsquo;re craving a more simple, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site. Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; CDN\\nYou can also use the jsDelivr CDN. I recommend linking to a specific version number or version range to prevent major updates from breaking your site. Reef uses semantic versioning.\\n\\u0026lt;!-- Always get the latest version --\\u0026gt; \\u0026lt;!-- Not recommended for production sites! --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get minor updates and patch fixes within a major version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@1/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get patch fixes within a minor version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@1.0/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get a specific version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@1.0.0/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; 2. Add an element to render your component/UI into. This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works var app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too var elem = document.querySelector(\\u0026#39;#app\\u0026#39;); var app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\n// Your template can be a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; } });  Note: You can use old-school strings, or if you\\u0026rsquo;d prefer, ES6 template literals.\\n[Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe state data is automatically passed into your template function, so that you can use it to customize your template.\\n// Some data var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;, \\u0026#39; + props.name + \\u0026#39;!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  4. Render your component You can render your component by calling the .render() method on it.\\napp.render();  Here\\u0026rsquo;s a demo.\\nState Management Reef provides two different ways to manage your state: reactive and manual.\\nData Reactivity Data reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\nYou can get an immutable clone of your current state using the getData() method. This lets you make any updates or changes you want without affecting the actual state of your component.\\nvar data = app.getData(); data.greeting = \\u0026#39;Hi there\\u0026#39;;  When you\\u0026rsquo;re ready to update your state, use the setData() method to update the state and cause the UI to render (if anything has changed).\\nThe setData() method accepts an object with your changed state as an argument. You don\\u0026rsquo;t need to pass in the whole state again\\u0026mdash;only what\\u0026rsquo;s changed.\\n// Pass in an entirely new state app.setData({ greeting: \\u0026#39;Hi there\\u0026#39;, name: \\u0026#39;universe\\u0026#39; }); // Or update just one key app.setData({greeting: \\u0026#39;Hi there\\u0026#39;});  Try data reactivity on CodePen \\u0026rarr;\\nManual State Sometimes, you want more manual control over when your UI renders again.\\nYou can update your component\\u0026rsquo;s state by directly accessing the data property of the component. After updating your state, run the .render() method again to update the DOM.\\napp.data.greeting = \\u0026#39;Hi there\\u0026#39;; app.data.name = \\u0026#39;universe\\u0026#39;; app.render();  Try manual state management on CodePen \\u0026rarr;\\nAdvanced Components Nested Components If you\\u0026rsquo;re managing a bigger app, you may have components inside components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key in your options. This accepts an array of components to attach your nested component to. You only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\nYou can access a parent component\\u0026rsquo;s state from a nested component by assigning the parent component data property to the data key in your nested component\\u0026rsquo;s options.\\n// Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: app.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods. Both methods accept both individual components or arrays of components as arguments.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State There are two ways to handle shared state with Reef when your components (in addition to the nested component/parent component relationship documented above).\\nSource of Truth Object You can associate a named data object with multiple components.\\nThe biggest downside to this approach is that it\\u0026rsquo;s non-reactive. You need to manually run the render() method on any component that needs to be updated when you update the state.\\nvar sourceOfTruth = { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }; // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); // Initial render app.render(); // Update the state sourceOfTruth.greeting = \\u0026#39;Hi, universe\\u0026#39;; // Re-render the DOM app.render();  Try working with a single source of truth on CodePen \\u0026rarr;\\nCreate a Lagoon A lagoon is a Reef instance that\\u0026rsquo;s only purpose is to store shared data.\\nIt doesn\\u0026rsquo;t render any UI in the DOM, but allows you to reactively update state using the setData() method. You can automatically trigger renders in other components by attaching them to your lagoon.\\nCreate a lagoon by setting the lagoon option to true when creating your Reef instance.\\nvar sourceOfTruth = new Reef(null, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, lagoon: true }); // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth] }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth, app] }); // Initial render app.render(); // Reactively update state sourceOfTruth.setData({greeting: \\u0026#39;Hi, universe\\u0026#39;});  Try creating a lagoon on CodePen \\u0026rarr;\\nAllowed Attributes One of the most important things Reef does is sanitize your templates to help reduce the risk of cross-site scripting attacks.\\nAs a result, by default certain attributes and properties cannot be applied to your element. This includes things like onerror events and custom element attributes (like sandwich=\\u0026quot;tuna\\u0026quot;).\\nYou can add exceptions to these rules using the addAttributes() method. It accepts individual attribute names, or an array of attributes.\\n// This works Reef.addAttributes(\\u0026#39;onerror\\u0026#39;); // This does, too Reef.addAttributes([\\u0026#39;onerror\\u0026#39;, \\u0026#39;sandwich\\u0026#39;]);  Heads up! This can expose you to more risk of a cross-site scripting attack. Use with caution.\\nYou can also remove an attribute or attributes using the removeAttributes() method.\\n// This works Reef.removeAttributes(\\u0026#39;onerror\\u0026#39;); // This does, too Reef.removeAttributes([\\u0026#39;onerror\\u0026#39;, \\u0026#39;sandwich\\u0026#39;]);  Try adding custom attributes on CodePen \\u0026rarr;\\nCustom Events Whenever Reef updates the DOM, it emits a custom render event that you can listen for with addEventListener().\\nThe render event is emitted on the element that was update, and bubbles, so you can use event delegation if you\\u0026rsquo;d prefer.\\ndocument.addEventListener(\\u0026#39;render\\u0026#39;, function (event) { if (event.target.matches(\\u0026#39;#app\\u0026#39;)) { // Do something... \\t} }, false);  Try the render event on CodePen \\u0026rarr;\\nDemos  Clock Mirror Typing Pomodoro Timer Stopwatch Todo List  What\\u0026rsquo;s new?  All polyfills have been removed and are no longer needed. This is a breaking change, as the .polyfill versions of scripts no longer exist.  Browser Compatibility Reef works in all modern browsers, and IE 10 and above.\\nLicense The code is available under the MIT License.\\n\",\"title\":\"Reef v1\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v1/\"},{\"content\":\" A lightweight library for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features  Weighs just 3kb minified and gzipped, with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a \\u0026lt;script\\u0026gt; element or ES module import\\u0026mdash;no command line or transpiling required (though you can if you want). Uses DOM diffing to update only the things that have changed. Has Redux/Vuex-like data stores, with setters and getters baked right in. Automatically sanitizes HTML before rendering to help protect you from cross-site scripting (XSS) attacks. Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Compatible with all modern browsers.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef only updates things that have changed instead of clobbering the DOM and removing focus from your form fields. It also automatically renders a new UI when your data updates, and helps protect you from XSS attacks.\\nIf you\\u0026rsquo;re craving a simpler, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site Reef works without any build step.\\nThe CDN is the fastest and simplest way to get started, but you can use importable modules or a direct download if you\\u0026rsquo;d prefer.\\n\\u0026lt;!-- Get the latest major version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@10/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; Reef uses semantic versioning. You can grab a major, minor, or patch version from the CDN with the @1.2.3 syntax. You can find all available versions under releases.\\n More ways to install Reef ES Modules\\nReef also supports modern browsers and module bundlers (like Rollup, Webpack, Snowpack, and so on) using the ES modules import syntax. Use the .es version.\\nimport Reef from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@10/dist/reef.es.min.js\\u0026#39;;  NPM\\nYou can also use NPM (or your favorite package manager). First, install with NPM.\\nnpm install reefjs --save Then import the package.\\nimport Reef from \\u0026#39;reefjs\\u0026#39;;  CommonJS\\nIf you use NodeJS, you can import Reef using the require() method with the .cjs version.\\nlet Reef = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@10/dist/reef.cjs.min.js\\u0026#39;);  AMD\\nIf you use RequireJS, SystemJS, and other AMD formats, you can import Reef with the .amd version.\\nrequirejs([\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@10/dist/reef.amd.min.js\\u0026#39;], function (Reef) { //... });  Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\n2. Add an element to render your component/UI into This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works let app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too let elem = document.querySelector(\\u0026#39;#app\\u0026#39;); let app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\n// Your template can be a string let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  [Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe data object is automatically encoded and passed into your template function, so that you can use it to customize your template.\\n// Some data let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Template literals give you a simple, JSX-like templating experience.\\n4. Render your component Render your component by calling the render() method on it.\\napp.render();  Try the demo on CodePen \\u0026rarr;\\nState Management Reef uses data reactivity to update your UI.\\nData reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\n// Create a component let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } }); // Render the initial UI app.render(); // This causes component to update with \\u0026#34;Hi, universe\\u0026#34; app.data.greeting = \\u0026#39;Hi\\u0026#39;; app.data.name = \\u0026#39;Universe\\u0026#39;;  You can also update the entire data object.\\n// This will also update the UI app.data = { greeting: \\u0026#39;Hi\\u0026#39;, name: \\u0026#39;Universe\\u0026#39; };  Try data reactivity on CodePen \\u0026rarr;\\nFor better performance, multiple property updates may be batched into a single, asynchronous render. You can detect when a render has been completed using the reef:render event hook.\\nNon-Reactive Data Sometimes, you want to update data without updating the UI.\\nYou can get an immutable copy of your data with the Reef.prototype.dataCopy property. This returns an immutable, non-reactive copy of your data that won\\u0026rsquo;t affect the state of your component or cause a UI update.\\n// Get an immutable copy of the app.data let data = app.dataCopy; // Update the copy // This does NOT update the app.data or render a new UI data.name = \\u0026#39;Universe\\u0026#39;;  When you\\u0026rsquo;re ready to update your component data, you can set the component\\u0026rsquo;s data property to your cloned copy.\\n// Reactively update the component data app.data = data;  Try non-reactive data on CodePen \\u0026rarr;\\nAdvanced Components As your project gets bigger, the way you manage components and data may need to grow with it. Reef has some options to help make things a little easier.\\nHTML Templates Default and state-based HTML attributes You can use component data to conditionally include or change the value of HTML attributes in your template.\\nUse the reef-checked, reef-selected, and reef-value attributes to dynamically control the checked, selected, and value attributes, respectively. Use a falsy value when the item should not be checked or selected.\\nIn the example below, the checkbox is checked when agreeToTOS is true.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { agreeToTOS: true }, template: function (props) { return ` \\u0026lt;label\\u0026gt; \\u0026lt;input type=\\u0026#34;checkbox\\u0026#34; reef-checked=\\u0026#34;${agreeToTOS}\\u0026#34;\\u0026gt; \\u0026lt;/label\\u0026gt;`; } });  You might also want to use a default value when an element initially renders, but defer to any changes the user makes after that.\\nYou can do that with the reef-default-checked, reef-default-selected, and reef-default-value attributes.\\nIn this example, Hermione has the [selected] attribute on it when first rendered, but will defer to whatever changes the user makes when diffing and updating the UI.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return ` \\u0026lt;label for=\\u0026#34;wizards\\u0026#34;\\u0026gt;Who is the best wizard?\\u0026lt;/label\\u0026gt; \\u0026lt;select\\u0026gt; \\u0026lt;option\\u0026gt;Harry\\u0026lt;/option\\u0026gt; \\u0026lt;option reef-default-selected\\u0026gt;Hermione\\u0026lt;/option\\u0026gt; \\u0026lt;option\\u0026gt;Neville\\u0026lt;/option\\u0026gt; \\u0026lt;/select\\u0026gt;`; } });  Try controlling form attributes on CodePen \\u0026rarr;\\nPreventing Cross-Site Scripting (XSS) Attacks To reduce your risk of cross-site scripting (XSS) attacks, Reef automatically sanitizes the HTML from your template before rendering it.\\nIn the example below, the attempted XSS attack (the alert()) will not run. Safe HTML, like the bold in the greeting property, will be rendered as expected.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;\\u0026lt;strong\\u0026gt;Hello\\u0026lt;/strong\\u0026gt;\\u0026#39;, name: \\u0026#39;world\\u0026#39;, img: \\u0026#39;\\u0026lt;img src=\\u0026#34;x\\u0026#34; onerror=\\u0026#34;alert(1)\\u0026#34;\\u0026gt;\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt; ${props.img}`; } });  Try HTML sanitization on CodePen \\u0026rarr;\\nGetting the element the template is being rendered into An optional second argument is passed into the template() function: the element the template is being rendered into.\\nThis is particularly handy if you have data attributes on your element that affect what\\u0026rsquo;s rendered into the template.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34; data-greeting=\\u0026#34;Hello\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { name: \\u0026#39;world\\u0026#39; }, template: function (props, elem) { return `\\u0026lt;h1\\u0026gt;${elem.getAttribute(\\u0026#39;data-greeting\\u0026#39;)}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Try getting the HTML element that the template was rendered into on CodePen \\u0026rarr;\\nNested Components If you\\u0026rsquo;re managing a bigger app, you may have components nested inside other components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key on your options object. You can provide a component or array of components for a value.\\nYou only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\n// Parent component let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.greeting}\\u0026lt;/h1\\u0026gt; \\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;`; } }); // Nested component let todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: { todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, template: function (props) { return ` \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; }, attachTo: app }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods on the parent component.\\nProvide an individual component or array of components as an argument.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State with Data Stores A Data Store is a special Reef object that holds reactive data you can share with multiple components.\\nAny time you update the data in your Data Store, any components that use the data will also be updated, and will render again if there are any UI changes.\\nCreate a Data Store using the new Reef.Store() constructor.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] } });  To use your Data Store with a component, pass it in with the store property instead of providing a data object.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { store: store, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.heading}\\u0026lt;/h1\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } });  When using a Data Store, your component can still have its own local data as well.\\nThe local component data is merged into the store and pass into the template() function as a single props object.\\nlet store = new Reef.Store({ data: { todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] } }); let app = new Reef(\\u0026#39;#app\\u0026#39;, { store: store, data: { heading: \\u0026#39;My Todos\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.heading}\\u0026lt;/h1\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } });  Try creating a Data Store on CodePen \\u0026rarr;\\nNote: if any properties in your store and data that share the same name, the local component data gets priority.\\nSetters \\u0026amp; Getters Reef\\u0026rsquo;s reactive data makes updating your UI as simple as updating an object property.\\nBut as your app scales, you may find that keeping track of what\\u0026rsquo;s updating state and causing changes to the UI becomes harder to track and maintain.\\nSetters and getters provide you with a way to control how data flows in and out of your component.\\nSetters Setters are functions that update your component or store data.\\nCreate setters by passing in an object of setter functions with the setters property on your options object. The first parameter on a setter function must be the store or component data. You can add as many other parameters as you\\u0026rsquo;d like.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, setters: { // Add a new todo item to the component \\taddTodo: function (props, todo) { props.todos.push(todo); } } });  Use setter functions by calling the do() method on your component or store. Pass in the name of the setter, along with any required arguments (except for props).\\n// Add a new todo item store.do(\\u0026#39;addTodo\\u0026#39;, \\u0026#39;Take a nap... zzzz\\u0026#39;);  When a component or store has setter functions, they become the only way to update app or store data.\\nThis protects your component or store data from unwanted changes. The data property always returns an immutable copy.\\n// This will NOT update the store.data or the UI store.data.todos.push(\\u0026#39;Take a nap... zzzz\\u0026#39;);  Try working with setter functions on CodePen \\u0026rarr;\\nGetters Getters are functions that parse data from your component or store and return a value.\\nThey\\u0026rsquo;re useful if you need to manipulate and retrieve the same data across multiple views or components. Rather than having to import helper functions, you can attach them directly to the component or store.\\nCreate getters by passing in an object of getter functions with the getters property on your options object. The first parameter on a getter function must be the store or component data. You can add as many other parameters as you\\u0026rsquo;d like.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, getters: { total: function (props) { return props.todos.length; } } });  Use getter functions by calling the get() method on your component or store. Pass in the name of getter, along with any required arguments (except for props).\\n// Get the number of todo items store.get(\\u0026#39;total\\u0026#39;);  Try working with getter functions on CodePen \\u0026rarr;\\nAsynchronous Data You can use asynchronous data (such as content from an API) in your templates.\\nSet an initial default value, make your API call, and update the data property once you get data back. This will automatically trigger a render.\\n// Create an app let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { articles: [] }, template: function (props) { // If there are no articles  if (!props.articles.length) { return `\\u0026lt;p\\u0026gt;There are no articles.\\u0026lt;/p\\u0026gt;`; } // Otherwise, show the articles \\treturn ` \\u0026lt;ul\\u0026gt; ${props.articles.map(function (article) { return `\\u0026lt;li\\u0026gt; \\u0026lt;strong\\u0026gt;\\u0026lt;a href=\\u0026#34;#\\u0026#34;\\u0026gt;${article.title}.\\u0026lt;/a\\u0026gt;\\u0026lt;/strong\\u0026gt; ${article.body}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } }); // Fetch API data // Then, update the app data fetch(\\u0026#39;https://jsonplaceholder.typicode.com/posts\\u0026#39;).then(function (response) { return response.json(); }).then(function (data) { app.data.articles = data; });  Try create a template from asynchronous data on CodePen \\u0026rarr;\\nYou might also choose to hard-code a loading message in your markup.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;Loading...\\u0026lt;/div\\u0026gt; Debugging By default, Reef fails silently. You can put Reef into debug mode to expose helpful error message in the Console tab of your browser\\u0026rsquo;s Developer Tools.\\nTurn debug mode on or off with the Reef.debug() method. Pass in true to turn it on, and false to turn it off.\\n// Turns debug mode on Reef.debug(true); // Turns debug mode off Reef.debug(false);  API Reference Reef exposes a set of options, methods, and custom events that you can hook into.\\nGlobal Methods Run these methods directly on the Reef object.\\nReef.debug() Turn debug mode on or off. Pass in true to turn debug mode on, and false to turn it off.\\n// Turn debug mode on Reef.debug(true); // Turn debug mode off Reef.debug(false);  Reef.clone() Create an immutable copy of an array, object, Map(), or Set().\\nReef.clone({});  Reef.err() Log a warning in the console conditionally only if debug mode is on.\\nReef.err(\\u0026#39;You did something, silly!\\u0026#39;);  Reef.emit() Emit a custom event. Pass in the element to emit the event on, the event name, and optionally, event details as arguments.\\n// Emits the \\u0026#34;awesome\\u0026#34; event on the document Reef.emit(document, \\u0026#39;awesome\\u0026#39;); // Emit the \\u0026#34;awesome\\u0026#34; event on the #app element, with some details let app = document.querySelector(\\u0026#39;#app\\u0026#39;); Reef.emit(app, \\u0026#39;awesome\\u0026#39;, { whoIs: \\u0026#39;You are\\u0026#39; });  You can listen for custom events with the Element.addEventListener() method.\\nComponent Properties Access these properties on individual Reef components.\\nReef.prototype.data Get a reactive copy of the app data.\\nlet data = app.data;  Reef.prototype.dataCopy Get a non-reactive, immutable copy of the app data.\\nlet copy = app.dataCopy; // This will not update the component data or cause a render copy.todos.push(\\u0026#39;Zzzz... take a nap!\\u0026#39;);  Reef.prototype.elem The element the component is associated with. Returns a string or Node.\\nlet elem = app.elem;  Component Methods Run these methods on individual Reef components.\\nReef.prototype.render() Render a Reef component in the UI.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); app.render();  Reef.prototype.attach() Attach one or more components to a Reef component. Pass in the component or an array of components as an argument.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;ul id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/ul\\u0026gt;\\u0026#39; }); let todos = new Reef(\\u0026#39;#todos\\u0026#39;, { template: \\u0026#39;\\u0026lt;li\\u0026gt;Build something with Reef\\u0026lt;/li\\u0026gt;\\u0026#39; }); // Attach one item app.attach(todos); // Attach an array of items app.attach([todos]);  Reef.prototype.detach() Detach an attached component. Pass in the component or an array of components as an argument.\\n// Detach one component app.detach(todos); // Detach an array of components app.detach([todos]);  Reef.prototype.do() Run a setter function. Pass in the name of the setter, and a comma-separate list of any arguments.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { count: 0 }, template: function (props) { return count; }, setters: { increase: function (props) { props.count++; } } }); // Run the increase setter app.do(\\u0026#39;increase\\u0026#39;);  Reef.prototype.get() Run a getter function. Pass in the name of the getter, and a comma-separate list of any arguments.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { count: 0 }, template: function (props) { return count; }, getters: { count: function (props) { return props.count; } } }); // Run the count getter app.get(\\u0026#39;count\\u0026#39;);  Events Reef emits custom events throughout the lifecycle of a component or instance.\\nAll Reef events follow a reef:{event-name} pattern. Unless otherwise specified, all events are emitted on the document element. Event details can be accessed on the event.details property.\\n// Listen for when Reef components are rendered into the DOM document.addEventListener(\\u0026#39;reef:render\\u0026#39;, function (event) { console.log(event.target); // The element it was rendered into \\tconsole.log(event.detail); // The data used for the render });   reef:ready is emitted when Reef is loaded into the DOM and ready to use. reef:initialized is emitted when a new Reef component is initialized.  event.detail - the instance  reef:before-render is emitted on an element before a new UI is rendered into it.  event.target - the element the component is being rendered into event.detail - the current component data event.preventDefault() - stop the component from rendering  reef:render is emitted on an element after a new UI is rendered into it.  event.target - the element the component was rendered into event.detail - the component data at time of render  reef:attached is emitted when one or more components is attached to a component.  event.detail - an object with the component and an array of attached components  reef:detached is emitted when one or more components is detached from a component.  event.detail - an object with the component and an array of detached components   Options All of the options for Reef.\\n// This can be a string or a element let elem = \\u0026#39;#app\\u0026#39;; new Reef(elem, { // The component data \\tdata: {}, // A component or array of components to attach to \\tattachTo: [], // A data store to use \\t// If used, the data option is ignored \\tstore: null, // An object of setter methods \\tsetters: {}, // An object of getter methods \\tgetters: {} });  Demos Want to see Reef in action? Here are some demos and examples you can play with.\\n Clock Mirror Typing Pomodoro Timer Stopwatch Progress Bar Todo List Whack-a-Mole Game Articles from an API  Browser Compatibility Reef works in all modern browsers. That means:\\n The latest versions of Edge, Chrome, Firefox, and Safari. Mobile Safari, Chrome, and Firefox on Safari. WebView, Chrome, and Firefox for Android.  If you need to support older browsers, you\\u0026rsquo;ll need to transpile your code into ES5 with BabelJS.\\nLicense The code is available under the MIT License.\\n\",\"title\":\"Reef v10\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v10/\"},{\"content\":\" A lightweight helper function for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features:\\n Weighs under 8kb (minified and gzipped), with zero dependencies. Simple templating with JavaScript strings or template literals. Automatically sanitizes your templates to protect you from cross-site scripting attacks. Load it with a simple \\u0026lt;script\\u0026gt; tag\\u0026mdash;no command line or transpiling required. Updates only the parts of the DOM that have changed. Keep those form fields in focus! Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Supported all the way back to IE10.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef sanitizes your data before rendering to minimize the risk of XSS scripting attacks. It also only updates things that have changed instead clobbering the DOM and removing focus from your form fields.\\nIf you\\u0026rsquo;re craving a more simple, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site. Reef comes in two flavors: regular and unsafe.\\nThe full version includes DOMPurify, an HTML sanitizers that protects you from cross-site scripting attacks when including third-party and user-provided content in your templates.\\nThe unsafe version is only 2kb, but doesn\\u0026rsquo;t sanitize your templates. Only use this version if you\\u0026rsquo;re not using any third-party or user-supplied data in your templates.\\nDirect Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; CDN\\nYou can also use the jsDelivr CDN. I recommend linking to a specific version number or version range to prevent major updates from breaking your site. Reef uses semantic versioning.\\n\\u0026lt;!-- Always get the latest version --\\u0026gt; \\u0026lt;!-- Not recommended for production sites! --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get minor updates and patch fixes within a major version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@2/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get patch fixes within a minor version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@2.0/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get a specific version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@2.0.0/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; 2. Add an element to render your component/UI into. This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works var app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too var elem = document.querySelector(\\u0026#39;#app\\u0026#39;); var app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\n// Your template can be a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; } });  Note: You can use old-school strings, or if you\\u0026rsquo;d prefer, ES6 template literals.\\n[Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe state data is automatically passed into your template function, so that you can use it to customize your template.\\n// Some data var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;, \\u0026#39; + props.name + \\u0026#39;!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  4. Render your component You can render your component by calling the .render() method on it.\\napp.render();  Here\\u0026rsquo;s a demo.\\nState Management Reef provides two different ways to manage your state: reactive and manual.\\nData Reactivity Data reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\nYou can get an immutable clone of your current state using the getData() method. This lets you make any updates or changes you want without affecting the actual state of your component.\\nvar data = app.getData(); data.greeting = \\u0026#39;Hi there\\u0026#39;;  When you\\u0026rsquo;re ready to update your state, use the setData() method to update the state and cause the UI to render (if anything has changed).\\nThe setData() method accepts an object with your changed state as an argument. You don\\u0026rsquo;t need to pass in the whole state again\\u0026mdash;only what\\u0026rsquo;s changed.\\n// Pass in an entirely new state app.setData({ greeting: \\u0026#39;Hi there\\u0026#39;, name: \\u0026#39;universe\\u0026#39; }); // Or update just one key app.setData({greeting: \\u0026#39;Hi there\\u0026#39;});  Try data reactivity on CodePen \\u0026rarr;\\nManual State Sometimes, you want more manual control over when your UI renders again.\\nYou can update your component\\u0026rsquo;s state by directly accessing the data property of the component. After updating your state, run the .render() method again to update the DOM.\\napp.data.greeting = \\u0026#39;Hi there\\u0026#39;; app.data.name = \\u0026#39;universe\\u0026#39;; app.render();  Try manual state management on CodePen \\u0026rarr;\\nAdvanced Components Nested Components If you\\u0026rsquo;re managing a bigger app, you may have components inside components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key in your options. This accepts an array of components to attach your nested component to. You only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\nYou can access a parent component\\u0026rsquo;s state from a nested component by assigning the parent component data property to the data key in your nested component\\u0026rsquo;s options.\\n// Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: app.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods. Both methods accept both individual components or arrays of components as arguments.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State There are two ways to handle shared state with Reef when your components (in addition to the nested component/parent component relationship documented above).\\nSource of Truth Object You can associate a named data object with multiple components.\\nThe biggest downside to this approach is that it\\u0026rsquo;s non-reactive. You need to manually run the render() method on any component that needs to be updated when you update the state.\\nvar sourceOfTruth = { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }; // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); // Initial render app.render(); // Update the state sourceOfTruth.greeting = \\u0026#39;Hi, universe\\u0026#39;; // Re-render the DOM app.render();  Try working with a single source of truth on CodePen \\u0026rarr;\\nCreate a Lagoon A lagoon is a Reef instance that\\u0026rsquo;s only purpose is to store shared data.\\nIt doesn\\u0026rsquo;t render any UI in the DOM, but allows you to reactively update state using the setData() method. You can automatically trigger renders in other components by attaching them to your lagoon.\\nCreate a lagoon by setting the lagoon option to true when creating your Reef instance.\\nvar sourceOfTruth = new Reef(null, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, lagoon: true }); // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth] }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth, app] }); // Initial render app.render(); // Reactively update state sourceOfTruth.setData({greeting: \\u0026#39;Hi, universe\\u0026#39;});  Try creating a lagoon on CodePen \\u0026rarr;\\nSanitizing Templates One of the most important things Reef does is sanitize your templates to help reduce the risk of cross-site scripting attacks.\\nIf you\\u0026rsquo;re using the unsafe version of Reef, you need to set the sanitize option to false or it will throw an error and not run. Only do this if you\\u0026rsquo;re not using any third-party or user-provided data.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { sanitize: false });  Reef uses DOMPurify to sanitize your templates. It\\u0026rsquo;s fast, lightweight, and good.\\nDOMPurify is configurable. You can pass in an object of options with the sanitizeOptions property. Consult the DOMPurify documentation for available options.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { sanitizeOptions: {} });  See Reef\\u0026rsquo;s template sanitizing in action on CodePen \\u0026rarr;\\nCustom Events Whenever Reef updates the DOM, it emits a custom render event that you can listen for with addEventListener().\\nThe render event is emitted on the element that was update, and bubbles, so you can use event delegation if you\\u0026rsquo;d prefer.\\ndocument.addEventListener(\\u0026#39;render\\u0026#39;, function (event) { if (event.target.matches(\\u0026#39;#app\\u0026#39;)) { // Do something... \\t} }, false);  Try the render event on CodePen \\u0026rarr;\\nDemos  Clock Mirror Typing Pomodoro Timer Stopwatch Todo List  What\\u0026rsquo;s new?  DOMPurify is now the template sanitizing engine. The attribute exceptions feature has been removed in favor of DOMPurify\\u0026rsquo;s configuration options. The addAttributes() and removeAttributes() methods no longer exist. Reef now offers a smaller unsafe version for UIs that don\\u0026rsquo;t use any third-party or user-provided content. It does not sanitize templates before rendering, so use with caution. SVGs are now properly supported and will render correctly.  Browser Compatibility Reef works in all modern browsers, and IE 10 and above.\\nLicense The code is available under the MIT License. DOMPurify is licensed under the Apache License 2.0.\\n\",\"title\":\"Reef v2\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v2/\"},{\"content\":\" A lightweight helper function for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features:\\n Weighs under 3kb (minified and gzipped), with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a simple \\u0026lt;script\\u0026gt; tag\\u0026mdash;no command line or transpiling required. Updates only the parts of the DOM that have changed. Keep those form fields in focus! Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Supported all the way back to IE10.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef only updates things that have changed instead clobbering the DOM and removing focus from your form fields.\\nIf you\\u0026rsquo;re craving a more simple, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site. Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; CDN\\nYou can also use the jsDelivr CDN. I recommend linking to a specific version number or version range to prevent major updates from breaking your site. Reef uses semantic versioning.\\n\\u0026lt;!-- Always get the latest version --\\u0026gt; \\u0026lt;!-- Not recommended for production sites! --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get minor updates and patch fixes within a major version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@3/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get patch fixes within a minor version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@3.0/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get a specific version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@3.0.0/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; 2. Add an element to render your component/UI into. This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works var app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too var elem = document.querySelector(\\u0026#39;#app\\u0026#39;); var app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\nYou can use old-school strings, or if you\\u0026rsquo;d prefer, ES6 template literals.\\n// Your template can be a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; } });  Important! Reef does NOT sanitize templates by default, but provides simple hooks to add this feature. ALWAYS sanitize templates that include user-provided or third-party data to minimize the risk of cross-site scripting (XSS) attacks.\\n[Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe state data is automatically passed into your template function, so that you can use it to customize your template.\\n// Some data var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;, \\u0026#39; + props.name + \\u0026#39;!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  4. Render your component You can render your component by calling the .render() method on it.\\napp.render();  Here\\u0026rsquo;s a demo.\\nState Management Reef provides two different ways to manage your state: reactive and manual.\\nData Reactivity Data reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\nYou can get an immutable clone of your current state using the getData() method. This lets you make any updates or changes you want without affecting the actual state of your component.\\nvar data = app.getData(); data.greeting = \\u0026#39;Hi there\\u0026#39;;  When you\\u0026rsquo;re ready to update your state, use the setData() method to update the state and cause the UI to render (if anything has changed).\\nThe setData() method accepts an object with your changed state as an argument. You don\\u0026rsquo;t need to pass in the whole state again\\u0026mdash;only what\\u0026rsquo;s changed.\\n// Pass in an entirely new state app.setData({ greeting: \\u0026#39;Hi there\\u0026#39;, name: \\u0026#39;universe\\u0026#39; }); // Or update just one key app.setData({greeting: \\u0026#39;Hi there\\u0026#39;});  Try data reactivity on CodePen \\u0026rarr;\\nManual State Sometimes, you want more manual control over when your UI renders again.\\nYou can update your component\\u0026rsquo;s state by directly accessing the data property of the component. After updating your state, run the .render() method again to update the DOM.\\napp.data.greeting = \\u0026#39;Hi there\\u0026#39;; app.data.name = \\u0026#39;universe\\u0026#39;; app.render();  Try manual state management on CodePen \\u0026rarr;\\nAdvanced Components Sanitizing Templates Reef does not sanitize templates by default, but provides simple hooks to add this feature.\\nThis keeps Reef as tiny as possible, lets you only add sanitization if you need it, and gives you the flexibility to use your preferred sanitizer instead of one I chose for you.\\nThere are two ways to add a sanitizer:\\n Globally for all components. On a component-by-component basis.  Note: If user-provided or third-party data shouldn\\u0026rsquo;t contain any HTML, you can instead strip all HTML from your data while passing it into your component using a helper function like sanitizeHTML().\\nAdding a global sanitizer Add a sanitizer to all components with the Reef.setSanitizer() method.\\nPass in a callback function that accepts the HTML to be sanitized as an argument. Run your sanitizer, then return the sanitized markup string.\\nHere\\u0026rsquo;s an example using DOMPurify.\\n// Sanitize all components Reef.setSanitizer(function (html) { return DOMPurify.sanitize(html); });  Sanitizing individual components You can also sanitize individual components, or sanitize a component using a different approach than you use globally, with the sanitize option.\\nPass in a callback function that accepts the HTML to be sanitized as an argument. Run your sanitizer, then return the sanitized markup string.\\nHere\\u0026rsquo;s an example using DOMPurify.\\n// Sanitize an individual component var app = new Reef(\\u0026#39;#app\\u0026#39;, { sanitize: function (html) { return DOMPurify.sanitize(html); } });  Nested Components If you\\u0026rsquo;re managing a bigger app, you may have components inside components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key in your options. This accepts an array of components to attach your nested component to. You only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\nYou can access a parent component\\u0026rsquo;s state from a nested component by assigning the parent component data property to the data key in your nested component\\u0026rsquo;s options.\\n// Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: app.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods. Both methods accept both individual components or arrays of components as arguments.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State There are two ways to handle shared state with Reef when your components (in addition to the nested component/parent component relationship documented above).\\nSource of Truth Object You can associate a named data object with multiple components.\\nThe biggest downside to this approach is that it\\u0026rsquo;s non-reactive. You need to manually run the render() method on any component that needs to be updated when you update the state.\\nvar sourceOfTruth = { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }; // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); // Initial render app.render(); // Update the state sourceOfTruth.greeting = \\u0026#39;Hi, universe\\u0026#39;; // Re-render the DOM app.render();  Try working with a single source of truth on CodePen \\u0026rarr;\\nCreate a Lagoon A lagoon is a Reef instance that\\u0026rsquo;s only purpose is to store shared data.\\nIt doesn\\u0026rsquo;t render any UI in the DOM, but allows you to reactively update state using the setData() method. You can automatically trigger renders in other components by attaching them to your lagoon.\\nCreate a lagoon by setting the lagoon option to true when creating your Reef instance.\\nvar sourceOfTruth = new Reef(null, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, lagoon: true }); // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth] }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth, app] }); // Initial render app.render(); // Reactively update state sourceOfTruth.setData({greeting: \\u0026#39;Hi, universe\\u0026#39;});  Try creating a lagoon on CodePen \\u0026rarr;\\nCustom Events Whenever Reef updates the DOM, it emits a custom render event that you can listen for with addEventListener().\\nThe render event is emitted on the element that was update, and bubbles, so you can use event delegation if you\\u0026rsquo;d prefer.\\ndocument.addEventListener(\\u0026#39;render\\u0026#39;, function (event) { if (event.target.matches(\\u0026#39;#app\\u0026#39;)) { // Do something... \\t} }, false);  Try the render event on CodePen \\u0026rarr;\\nDemos  Clock Mirror Typing Pomodoro Timer Stopwatch Todo List  What\\u0026rsquo;s new?  Automatic sanitization has been removed. HTML templates are unsanitized by default. Two new hooks to add sanitization to your components have been added. This provides more developer flexibility and keeps Reef as lightweight as possible.  Browser Compatibility Reef works in all modern browsers, and IE 10 and above.\\nLicense The code is available under the MIT License.\\n\",\"title\":\"Reef v3\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v3/\"},{\"content\":\" A lightweight library for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features:\\n Weighs just 2.5kb (minified and gzipped) with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a \\u0026lt;script\\u0026gt; element\\u0026mdash;no command line or transpiling required. Updates only the parts of the DOM that have changed. Keep those form fields in focus! Automatically encodes markup in your data to protect you from cross-site scripting (XSS) attacks. Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Supported all the way back to IE9.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef only updates things that have changed instead clobbering the DOM and removing focus from your form fields. It also automatically renders a new UI when your data updates, and helps protect you from XSS attacks.\\nIf you\\u0026rsquo;re craving a simpler, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site. Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; CDN\\nYou can also use the jsDelivr CDN. I recommend linking to a specific version number or version range to prevent major updates from breaking your site. Reef uses semantic versioning.\\n\\u0026lt;!-- Always get the latest version --\\u0026gt; \\u0026lt;!-- Not recommended for production sites! --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get minor updates and patch fixes within a major version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@4/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get patch fixes within a minor version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@4.0/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;!-- Get a specific version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/gh/cferdinandi/reef@4.0.0/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; NPM\\nYou can also use NPM (or your favorite package manager).\\nnpm install reefjs 2. Add an element to render your component/UI into. This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works var app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too var elem = document.querySelector(\\u0026#39;#app\\u0026#39;); var app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\nYou can use old-school strings, or if you\\u0026rsquo;d prefer, ES6 template literals.\\n// Your template can be a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  [Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe state data is automatically passed into your template function, so that you can use it to customize your template. Reef also encodes any markup in your data before passing it into your template to reduce your risk of cross-site scripting (XSS) attacks.\\n// Some data var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;, \\u0026#39; + props.name + \\u0026#39;!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  4. Render your component You can render your component by calling the .render() method on it.\\napp.render();  Try the demo on CodePen \\u0026rarr;\\nState Management Reef provides two different ways to manage your state: reactive and manual.\\nData Reactivity Data reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\nYou can get an immutable clone of your current state using the getData() method. This lets you make any updates or changes you want without affecting the actual state of your component.\\nvar data = app.getData(); data.greeting = \\u0026#39;Hi there\\u0026#39;;  When you\\u0026rsquo;re ready to update your state, use the setData() method to update the state and cause the UI to render (if anything has changed).\\nThe setData() method accepts an object with your changed state as an argument. You don\\u0026rsquo;t need to pass in the whole state again\\u0026mdash;only what\\u0026rsquo;s changed.\\n// Pass in an entirely new state app.setData({ greeting: \\u0026#39;Hi there\\u0026#39;, name: \\u0026#39;universe\\u0026#39; }); // Or update just one key app.setData({greeting: \\u0026#39;Hi there\\u0026#39;});  Try data reactivity on CodePen \\u0026rarr;\\nManual State Sometimes, you want more manual control over when your UI renders again.\\nYou can update your component\\u0026rsquo;s state by directly accessing the data property of the component. After updating your state, run the .render() method again to update the DOM.\\napp.data.greeting = \\u0026#39;Hi there\\u0026#39;; app.data.name = \\u0026#39;universe\\u0026#39;; app.render();  Try manual state management on CodePen \\u0026rarr;\\nAdvanced Components HTML in your data Reef automatically encodes any markup in your data before passing it into your template to reduce your risk of cross-site scripting (XSS) attacks.\\nYou can disable this feature by setting the allowHTML option to true.\\nImportant! Do NOT do this with third-party or user-provided data. This exposes you to the risk of cross-site scripting (XSS) attacks.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;\\u0026lt;strong\\u0026gt;Hello\\u0026lt;/strong\\u0026gt;\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;, \\u0026#39; + props.name + \\u0026#39;!\\u0026lt;/h1\\u0026gt;\\u0026#39;; }, allowHTML: true // Do NOT use with third-party/user-supplied data });  Try allowing HTML in your data on CodePen \\u0026rarr;\\nDefault and state-based HTML attributes You can use component data to conditionally include or change the value of HTML attributes in your template.\\nIn the example below, the checkbox is checked when agreeToTOS is true.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { agreeToTOS: true }, template: function (props) { var html = \\u0026#39;\\u0026lt;label for=\\u0026#34;tos\\u0026#34;\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;input type=\\u0026#34;checkbox\\u0026#34; id=\\u0026#34;tos\\u0026#34; \\u0026#39; + (props.agreeToTOS ? \\u0026#39;checked\\u0026#39; : \\u0026#39;\\u0026#39;) + \\u0026#39;\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;/label\\u0026gt;\\u0026#39;; return html; } });  You might also want to use a default value for an attribute, but not change it based on your component\\u0026rsquo;s state. You can do that by prefixing any attribute with default in your template.\\nIn this example, option[value=\\u0026quot;hermione\\u0026quot;] has the [selected] attribute on it when first rendered, but will defer to whatever changes the user makes when diffing and updating the UI.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: {}, template: function () { var html = \\u0026#39;\\u0026lt;label for=\\u0026#34;wizards\\u0026#34;\\u0026gt;Who is the best wizard?\\u0026lt;/label\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;select\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;option value=\\u0026#34;harry\\u0026#34;\\u0026gt;Harry\\u0026lt;/option\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;option value=\\u0026#34;hermione\\u0026#34; defaultSelected\\u0026gt;Hermione\\u0026lt;/option\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;option value=\\u0026#34;neville\\u0026#34;\\u0026gt;Neville\\u0026lt;/option\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;/select\\u0026gt;\\u0026#39;; return html; } });  Nested Components If you\\u0026rsquo;re managing a bigger app, you may have components inside components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key in your options. This accepts an array of components to attach your nested component to. You only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\nYou can access a parent component\\u0026rsquo;s state from a nested component by assigning the parent component data property to the data key in your nested component\\u0026rsquo;s options.\\n// Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: app.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods. Both methods accept both individual components or arrays of components as arguments.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State There are two ways to handle shared state with Reef when your components (in addition to the nested component/parent component relationship documented above).\\nSource of Truth Object You can associate a named data object with multiple components.\\nThe biggest downside to this approach is that it\\u0026rsquo;s non-reactive. You need to manually run the render() method on any component that needs to be updated when you update the state.\\nvar sourceOfTruth = { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }; // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); // Initial render app.render(); // Update the state sourceOfTruth.greeting = \\u0026#39;Hi, universe\\u0026#39;; // Re-render the DOM app.render();  Try working with a single source of truth on CodePen \\u0026rarr;\\nCreate a Lagoon A lagoon is a Reef instance that\\u0026rsquo;s only purpose is to store shared data.\\nIt doesn\\u0026rsquo;t render any UI in the DOM, but allows you to reactively update state using the setData() method. You can automatically trigger renders in other components by attaching them to your lagoon.\\nCreate a lagoon by setting the lagoon option to true when creating your Reef instance.\\nvar sourceOfTruth = new Reef(null, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, lagoon: true }); // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth] }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth, app] }); // Initial render app.render(); // Reactively update state sourceOfTruth.setData({greeting: \\u0026#39;Hi, universe\\u0026#39;});  Try creating a lagoon on CodePen \\u0026rarr;\\nCustom Events Whenever Reef updates the DOM, it emits a custom render event that you can listen for with addEventListener().\\nThe render event is emitted on the element that was update, and bubbles, so you can use event delegation if you\\u0026rsquo;d prefer.\\nThe event.detail property includes a copy of the data at the time that the template was rendered.\\ndocument.addEventListener(\\u0026#39;render\\u0026#39;, function (event) { // Only run for elements with the #app ID \\tif (!event.target.matches(\\u0026#39;#app\\u0026#39;)) return; // The data for this template \\tvar data = event.detail; }, false);  Try the render event on CodePen \\u0026rarr;\\nEmitting your own custom events Reef includes a helper function, Reef.emit(), that you can use to emit your own custom events in your apps.\\nPass in the element to emit the event on and the event name as arguments. You can optionally pass in an object with event details as a third argument.\\n// Emit the \\u0026#39;partyTime\\u0026#39; event on the document element Reef.emit(document, \\u0026#39;partyTime\\u0026#39;, { msg: \\u0026#39;It\\\\\\u0026#39;s party time!\\u0026#39; });  Debugging By default, Reef fails silently. You can put Reef into debugging mode to expose helpful error message in the Console tab of your browser\\u0026rsquo;s Developer Tools.\\nTurn debugging mode on or off with the Reef.debug() method. Pass in true to turn it on, and false to turn it off.\\n// Turns debugging mode on Reef.debug(true); // Turns debugging mode off Reef.debug(false);  Demos  Clock Mirror Typing Pomodoro Timer Stopwatch Todo List Whack-a-Mole Game  What\\u0026rsquo;s new?  Data is once again automatically encoded to help protect you from cross-site scripting (XSS) attacks. Changes to diffing and rendering reduce reflows and improve performance. Support pushed back even further to IE9. Deprecated: Custom sanitizer methods were removed in favor of built-in, automated HTML encoding. You can still add custom sanitization within template functions.  Browser Compatibility Reef works in all modern browsers, and IE 9 and above.\\nLicense The code is available under the MIT License.\\n\",\"title\":\"Reef v4\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v4/\"},{\"content\":\" A lightweight library for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features  Weighs just 2.3kb (minified and gzipped) with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a \\u0026lt;script\\u0026gt; element\\u0026mdash;no command line or transpiling required. Updates only the parts of the DOM that have changed. Keep those form fields in focus! Automatically encodes markup in your data to protect you from cross-site scripting (XSS) attacks. Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Supported all the way back to IE9.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef only updates things that have changed instead clobbering the DOM and removing focus from your form fields. It also automatically renders a new UI when your data updates, and helps protect you from XSS attacks.\\nIf you\\u0026rsquo;re craving a simpler, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; CDN\\nYou can also use the jsDelivr CDN.\\n\\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; Reef using semantic versioning. You can grab a major, minor, or patch version from the CDN with the @1.2.3 syntax. You can find all available versions under releases.\\n\\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@5.0.0/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; ES Modules\\nReef now supports modern browsers and module bundlers (like Rollup, Webpack, Snowpack, and so on) using the ES modules import syntax. Use the .es version.\\nimport Reef from \\u0026#39;path/to/reef.es.min.js\\u0026#39;;   More ways to install Reef CommonJS\\nIf you use NodeJS, you can import Reef using the require() method with the .cjs version.\\nvar Reef = require(\\u0026#39;path/to/reef.cjs.min.js\\u0026#39;);  AMD\\nIf you use RequireJS, SystemJS, and other AMD formats, you can import Reef with the .amd version.\\nrequirejs([\\u0026#39;path/to/reef.amd.min.js\\u0026#39;], function (Reef) { //... });  NPM\\nYou can also use NPM (or your favorite package manager).\\nnpm install reefjs --save \\n2. Add an element to render your component/UI into This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works var app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too var elem = document.querySelector(\\u0026#39;#app\\u0026#39;); var app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\nYou can use old-school strings, or if you\\u0026rsquo;d prefer, ES6 template literals.\\n// Your template can be a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  [Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe state data is automatically passed into your template function, so that you can use it to customize your template. Reef also encodes any markup in your data before passing it into your template to reduce your risk of cross-site scripting (XSS) attacks.\\n// Some data var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;, \\u0026#39; + props.name + \\u0026#39;!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  4. Render your component You can render your component by calling the .render() method on it.\\napp.render();  Try the demo on CodePen \\u0026rarr;\\nState Management Reef provides two different ways to manage your state: reactive and manual.\\nData Reactivity Data reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\nYou can get an immutable clone of your current state using the getData() method. This lets you make any updates or changes you want without affecting the actual state of your component.\\nvar data = app.getData(); data.greeting = \\u0026#39;Hi there\\u0026#39;;  When you\\u0026rsquo;re ready to update your state, use the setData() method to update the state and cause the UI to render (if anything has changed).\\nThe setData() method accepts an object with your changed state as an argument. You don\\u0026rsquo;t need to pass in the whole state again\\u0026mdash;only what\\u0026rsquo;s changed.\\n// Pass in an entirely new state app.setData({ greeting: \\u0026#39;Hi there\\u0026#39;, name: \\u0026#39;universe\\u0026#39; }); // Or update just one key app.setData({greeting: \\u0026#39;Hi there\\u0026#39;});  Try data reactivity on CodePen \\u0026rarr;\\nManual State Sometimes, you want more manual control over when your UI renders again.\\nYou can update your component\\u0026rsquo;s state by directly accessing the data property of the component. After updating your state, run the .render() method again to update the DOM.\\napp.data.greeting = \\u0026#39;Hi there\\u0026#39;; app.data.name = \\u0026#39;universe\\u0026#39;; app.render();  Try manual state management on CodePen \\u0026rarr;\\nAdvanced Components HTML in your data Reef automatically encodes any markup in your data before passing it into your template to reduce your risk of cross-site scripting (XSS) attacks.\\nYou can disable this feature by setting the allowHTML option to true.\\nImportant! Do NOT do this with third-party or user-provided data. This exposes you to the risk of cross-site scripting (XSS) attacks.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;\\u0026lt;strong\\u0026gt;Hello\\u0026lt;/strong\\u0026gt;\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;, \\u0026#39; + props.name + \\u0026#39;!\\u0026lt;/h1\\u0026gt;\\u0026#39;; }, allowHTML: true // Do NOT use with third-party/user-supplied data });  Try allowing HTML in your data on CodePen \\u0026rarr;\\nDefault and state-based HTML attributes You can use component data to conditionally include or change the value of HTML attributes in your template.\\nIn the example below, the checkbox is checked when agreeToTOS is true.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { agreeToTOS: true }, template: function (props) { var html = \\u0026#39;\\u0026lt;label for=\\u0026#34;tos\\u0026#34;\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;input type=\\u0026#34;checkbox\\u0026#34; id=\\u0026#34;tos\\u0026#34; \\u0026#39; + (props.agreeToTOS ? \\u0026#39;checked\\u0026#39; : \\u0026#39;\\u0026#39;) + \\u0026#39;\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;/label\\u0026gt;\\u0026#39;; return html; } });  You might also want to use a default value for an attribute, but not change it based on your component\\u0026rsquo;s state. You can do that by prefixing any attribute with default in your template.\\nIn this example, option[value=\\u0026quot;hermione\\u0026quot;] has the [selected] attribute on it when first rendered, but will defer to whatever changes the user makes when diffing and updating the UI.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: {}, template: function () { var html = \\u0026#39;\\u0026lt;label for=\\u0026#34;wizards\\u0026#34;\\u0026gt;Who is the best wizard?\\u0026lt;/label\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;select\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;option value=\\u0026#34;harry\\u0026#34;\\u0026gt;Harry\\u0026lt;/option\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;option value=\\u0026#34;hermione\\u0026#34; defaultSelected\\u0026gt;Hermione\\u0026lt;/option\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;option value=\\u0026#34;neville\\u0026#34;\\u0026gt;Neville\\u0026lt;/option\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;/select\\u0026gt;\\u0026#39;; return html; } });  Nested Components If you\\u0026rsquo;re managing a bigger app, you may have components inside components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key in your options. This accepts an array of components to attach your nested component to. You only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\nYou can access a parent component\\u0026rsquo;s state from a nested component by assigning the parent component data property to the data key in your nested component\\u0026rsquo;s options.\\n// Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: app.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods. Both methods accept both individual components or arrays of components as arguments.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State There are two ways to handle shared state with Reef when your components (in addition to the nested component/parent component relationship documented above).\\nSource of Truth Object You can associate a named data object with multiple components.\\nThe biggest downside to this approach is that it\\u0026rsquo;s non-reactive. You need to manually run the render() method on any component that needs to be updated when you update the state.\\nvar sourceOfTruth = { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }; // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [app] }); // Initial render app.render(); // Update the state sourceOfTruth.greeting = \\u0026#39;Hi, universe\\u0026#39;; // Re-render the DOM app.render();  Try working with a single source of truth on CodePen \\u0026rarr;\\nCreate a Lagoon A lagoon is a Reef instance that\\u0026rsquo;s only purpose is to store shared data.\\nIt doesn\\u0026rsquo;t render any UI in the DOM, but allows you to reactively update state using the setData() method. You can automatically trigger renders in other components by attaching them to your lagoon.\\nCreate a lagoon by setting the lagoon option to true when creating your Reef instance.\\nvar sourceOfTruth = new Reef(null, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, lagoon: true }); // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h1\\u0026gt;\\u0026#39; + props.greeting + \\u0026#39;\\u0026lt;/h1\\u0026gt;\\u0026#39; + \\u0026#39;\\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth] }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { var html = \\u0026#39;\\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt;\\u0026lt;ul\\u0026gt;\\u0026#39;; props.todos.forEach(function (todo) { html += \\u0026#39;\\u0026lt;li\\u0026gt;\\u0026#39; + todo + \\u0026#39;\\u0026lt;/li\\u0026gt;\\u0026#39;; }); html += \\u0026#39;\\u0026lt;/ul\\u0026gt;\\u0026#39;; return html; }, attachTo: [sourceOfTruth, app] }); // Initial render app.render(); // Reactively update state sourceOfTruth.setData({greeting: \\u0026#39;Hi, universe\\u0026#39;});  Try creating a lagoon on CodePen \\u0026rarr;\\nThe render event Whenever Reef updates the DOM, it emits a custom render event that you can listen for with addEventListener().\\nThe render event is emitted on the element that was update, and bubbles, so you can use event delegation if you\\u0026rsquo;d prefer.\\nThe event.detail property includes a copy of the data at the time that the template was rendered.\\ndocument.addEventListener(\\u0026#39;render\\u0026#39;, function (event) { // Only run for elements with the #app ID \\tif (!event.target.matches(\\u0026#39;#app\\u0026#39;)) return; // The data for this template \\tvar data = event.detail; }, false);  Try the render event on CodePen \\u0026rarr;\\nEmitting your own custom events Reef includes a helper function, Reef.emit(), that you can use to emit your own custom events in your apps.\\nPass in the element to emit the event on and the event name as arguments. You can optionally pass in an object with event details as a third argument.\\n// Emit the \\u0026#39;partyTime\\u0026#39; event on the document element Reef.emit(document, \\u0026#39;partyTime\\u0026#39;, { msg: \\u0026#39;It\\\\\\u0026#39;s party time!\\u0026#39; });  Debugging By default, Reef fails silently. You can put Reef into debugging mode to expose helpful error message in the Console tab of your browser\\u0026rsquo;s Developer Tools.\\nTurn debugging mode on or off with the Reef.debug() method. Pass in true to turn it on, and false to turn it off.\\n// Turns debugging mode on Reef.debug(true); // Turns debugging mode off Reef.debug(false);  Demos Want to see Reef in action? Here are some demos and examples you can play with.\\n Clock Mirror Typing Pomodoro Timer Stopwatch Todo List Whack-a-Mole Game  Changelog  Specific named versions for ES modules, AMD, and CommonJS. Default build is browser-only. ES modules now natively supported.  Browser Compatibility Reef works in all modern browsers, and IE 9 and above.\\nLicense The code is available under the MIT License.\\n\",\"title\":\"Reef v5\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v5/\"},{\"content\":\" A lightweight library for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features  Weighs just 2.4kb (minified and gzipped) with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a \\u0026lt;script\\u0026gt; element or ES module import\\u0026mdash;no command line or transpiling required. Uses DOM diffing to update only the things that have changed. Automatically encodes markup in your data to protect you from cross-site scripting (XSS) attacks. Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Supported all the way back to IE9.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef only updates things that have changed instead clobbering the DOM and removing focus from your form fields. It also automatically renders a new UI when your data updates, and helps protect you from XSS attacks.\\nIf you\\u0026rsquo;re craving a simpler, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site Reef comes in two flavors: standalone and polyfilled.\\nThe polyfilled build uses the .polyfill suffix, and includes polyfills for Proxies and Custom Events, which are required for IE support.\\nCDN\\nYou can also use the jsDelivr CDN.\\n\\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; Reef using semantic versioning. You can grab a major, minor, or patch version from the CDN with the @1.2.3 syntax. You can find all available versions under releases.\\n\\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@6/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; ES Modules\\nReef now supports modern browsers and module bundlers (like Rollup, Webpack, Snowpack, and so on) using the ES modules import syntax. Use the .es version.\\nimport Reef from \\u0026#39;path/to/reef.es.min.js\\u0026#39;;   More ways to install Reef Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; CommonJS\\nIf you use NodeJS, you can import Reef using the require() method with the .cjs version.\\nvar Reef = require(\\u0026#39;path/to/reef.cjs.min.js\\u0026#39;);  AMD\\nIf you use RequireJS, SystemJS, and other AMD formats, you can import Reef with the .amd version.\\nrequirejs([\\u0026#39;path/to/reef.amd.min.js\\u0026#39;], function (Reef) { //... });  NPM\\nYou can also use NPM (or your favorite package manager).\\nnpm install reefjs --save \\n2. Add an element to render your component/UI into This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works var app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too var elem = document.querySelector(\\u0026#39;#app\\u0026#39;); var app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\nYou can use old-school strings, or if you\\u0026rsquo;d prefer, ES6 template literals.\\n// Your template can be a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  [Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe data object is automatically encoded and passed into your template function, so that you can use it to customize your template.\\n// Some data var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Template literals give you a simple, JSX-like templating experience. If you want, you can use old-school concatenated strings for more backwards compatibility.\\n4. Render your component You can render your component by calling the .render() method on it.\\napp.render();  Try the demo on CodePen \\u0026rarr;\\nState Management Reef uses data reactivity to update your UI.\\nData reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\n// Create a component and render it var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } }); app.render(); // This causes component to update with \\u0026#34;Hi, universe\\u0026#34; app.data.greeting = \\u0026#39;Hi\\u0026#39;; app.data.name = \\u0026#39;Universe\\u0026#39;;  You can also update the entire data object.\\n// This will also update the UI app.data = { greeting: \\u0026#39;Hi\\u0026#39;, name: \\u0026#39;Universe\\u0026#39; };  Try data reactivity on CodePen \\u0026rarr;\\nUpdating data without reactivity Sometimes, you want to update data without updating the UI.\\nYou can get an immutable copy of your data using the clone() method. This creates a non-reactive copy of your data that won\\u0026rsquo;t affect the state of your component.\\nvar data = app.clone();  And starting with v6.1.0, you can immutably clone any array or object using the Reef.clone() method. Pass in the object to clone as an argument.\\n// Changes you make to data won\\u0026#39;t affect dataClone and vice-versa var dataClone = Reef.clone(data);  Advanced Components HTML in your data Reef automatically encodes any markup in your data before passing it into your template to reduce your risk of cross-site scripting (XSS) attacks.\\nYou can disable this feature by setting the allowHTML option to true.\\nImportant! Do NOT do this with third-party or user-provided data. This exposes you to the risk of cross-site scripting (XSS) attacks.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;\\u0026lt;strong\\u0026gt;Hello\\u0026lt;/strong\\u0026gt;\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; }, allowHTML: true // Do NOT use with third-party/user-supplied data });  Try allowing HTML in your data on CodePen \\u0026rarr;\\nDefault and state-based HTML attributes You can use component data to conditionally include or change the value of HTML attributes in your template.\\nIn the example below, the checkbox is checked when agreeToTOS is true.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { agreeToTOS: true }, template: function (props) { return ` \\u0026#39;\\u0026lt;label for=\\u0026#34;tos\\u0026#34;\\u0026gt; \\u0026lt;input type=\\u0026#34;checkbox\\u0026#34; id=\\u0026#34;tos\\u0026#34; ${props.agreeToTOS ? \\u0026#39;checked\\u0026#39; : \\u0026#39;\\u0026#39;}\\u0026gt; \\u0026lt;/label\\u0026gt;`; } });  You might also want to use a default value for an attribute, but not change it based on your component\\u0026rsquo;s state. You can do that by prefixing any attribute with default in your template.\\nIn this example, option[value=\\u0026quot;hermione\\u0026quot;] has the [selected] attribute on it when first rendered, but will defer to whatever changes the user makes when diffing and updating the UI.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: {}, template: function () { return ` \\u0026lt;label for=\\u0026#34;wizards\\u0026#34;\\u0026gt;Who is the best wizard?\\u0026lt;/label\\u0026gt; \\u0026lt;select\\u0026gt; \\u0026lt;option value=\\u0026#34;harry\\u0026#34;\\u0026gt;Harry\\u0026lt;/option\\u0026gt; \\u0026lt;option value=\\u0026#34;hermione\\u0026#34; defaultSelected\\u0026gt;Hermione\\u0026lt;/option\\u0026gt; \\u0026lt;option value=\\u0026#34;neville\\u0026#34;\\u0026gt;Neville\\u0026lt;/option\\u0026gt; \\u0026lt;/select\\u0026gt;`; } });  Nested Components If you\\u0026rsquo;re managing a bigger app, you may have components inside components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key in your options. This accepts an array of components to attach your nested component to. You only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\nYou can access a parent component\\u0026rsquo;s state from a nested component by assigning the parent component data property to the data key in your nested component\\u0026rsquo;s options.\\n// Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.greeting}\\u0026lt;/h1\\u0026gt; \\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;`; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: app.data, template: function (props) { return ` \\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; }, attachTo: [app] }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods.\\nBoth methods accept individual components or arrays of components as arguments.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State There are two ways to handle shared state with Reef when your components (in addition to the nested component/parent component relationship documented above).\\nSource of Truth Object You can associate a named data object with multiple components.\\nThe biggest downside to this approach is that it\\u0026rsquo;s non-reactive. You need to manually run the render() method on any component that needs to be updated when you update the state.\\nvar sourceOfTruth = { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }; // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.greeting}\\u0026lt;/h1\\u0026gt; \\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;`; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth, template: function (props) { return ` \\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; }, attachTo: [app] }); // Initial render app.render(); // Update the state sourceOfTruth.greeting = \\u0026#39;Hi, universe\\u0026#39;; // Re-render the DOM app.render();  Try working with a single source of truth on CodePen \\u0026rarr;\\nData Stores (aka Lagoons) A lagoon is a Reef instance that\\u0026rsquo;s only purpose is to reactively store shared data.\\nCreate a lagoon by setting the lagoon option to true when creating your Reef instance. A lagoon doesn\\u0026rsquo;t have a template of its own, but automatically updates the UI of any attached components when its data is updated.\\nvar sourceOfTruth = new Reef(null, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39;, todos: [ \\u0026#39;Buy milk\\u0026#39;, \\u0026#39;Bake a birthday cake\\u0026#39;, \\u0026#39;Go apple picking\\u0026#39; ] }, lagoon: true }); // Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.greeting}\\u0026lt;/h1\\u0026gt; \\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;`; }, attachTo: [sourceOfTruth] }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: sourceOfTruth.data, template: function (props) { return ` \\u0026lt;h2\\u0026gt;Todo List\\u0026lt;/h2\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; }, attachTo: [sourceOfTruth, app] }); // Initial render app.render(); // Reactively update state sourceOfTruth.data.greeting = \\u0026#39;Hi, universe\\u0026#39;;  Try creating a lagoon on CodePen \\u0026rarr;\\nThe render event Whenever Reef updates the DOM, it emits a custom render event that you can listen for with addEventListener().\\nThe render event is emitted on the element that was updated, and bubbles, so you can use event delegation if you\\u0026rsquo;d prefer.\\nThe event.detail property includes a copy of the data at the time that the template was rendered.\\ndocument.addEventListener(\\u0026#39;render\\u0026#39;, function (event) { // Only run for elements with the #app ID \\tif (!event.target.matches(\\u0026#39;#app\\u0026#39;)) return; // The data for this template \\tvar data = event.detail; }, false);  Try the render event on CodePen \\u0026rarr;\\nEmitting your own custom events Reef includes a helper function, Reef.emit(), that you can use to emit your own custom events in your apps.\\nPass in the element to emit the event on and the event name as arguments. You can optionally pass in an object with event details as a third argument.\\n// Emit the \\u0026#39;partyTime\\u0026#39; event on the document element Reef.emit(document, \\u0026#39;partyTime\\u0026#39;, { msg: `It\\u0026#39;s party time!` });  Debugging By default, Reef fails silently. You can put Reef into debugging mode to expose helpful error message in the Console tab of your browser\\u0026rsquo;s Developer Tools.\\nTurn debugging mode on or off with the Reef.debug() method. Pass in true to turn it on, and false to turn it off.\\n// Turns debugging mode on Reef.debug(true); // Turns debugging mode off Reef.debug(false);  Demos Want to see Reef in action? Here are some demos and examples you can play with.\\n Clock Mirror Typing Pomodoro Timer Stopwatch Todo List Whack-a-Mole Game  Changelog  Component data is now directly reactive. The setData() and getData() methods (previously used for reactivity) have been removed. You can get an immutable copy of your data with the clone() method. Added an emit() method for emitting custom events. IE support now requires polyfills or transpiling.  Browser Compatibility Reef works in all modern browsers, and IE 9 and above.\\nLicense The code is available under the MIT License.\\n\",\"title\":\"Reef v6\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v6/\"},{\"content\":\" A lightweight library for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features  Weighs just 2.5kb minified and gzipped, with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a \\u0026lt;script\\u0026gt; element or ES module import\\u0026mdash;no command line or transpiling required. Uses DOM diffing to update only the things that have changed. Has Redux/Vuex-like data stores, setters and getters baked right in. Automatically encodes markup in your data to protect you from cross-site scripting (XSS) attacks. Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Supported all the way back to IE9.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef only updates things that have changed instead of clobbering the DOM and removing focus from your form fields. It also automatically renders a new UI when your data updates, and helps protect you from XSS attacks.\\nIf you\\u0026rsquo;re craving a simpler, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site Reef comes in two flavors: standalone and polyfilled.\\nThe polyfilled build uses the .polyfill suffix, and includes the polyfills for Proxies and Custom Events that are required for IE support.\\nCDN\\nThe fastest way to get started is with the CDN from jsDelivr.\\n\\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; Reef uses semantic versioning. You can grab a major, minor, or patch version from the CDN with the @1.2.3 syntax. You can find all available versions under releases.\\n\\u0026lt;!-- Use the latest major version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@7/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; ES Modules\\nReef also supports modern browsers and module bundlers (like Rollup, Webpack, Snowpack, and so on) using the ES modules import syntax. Use the .es version.\\nimport Reef from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.es.min.js\\u0026#39;;   More ways to install Reef Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; NPM\\nYou can also use NPM (or your favorite package manager). First, install with NPM.\\nnpm install reefjs --save Then import the package.\\nimport Reef from \\u0026#39;reefjs\\u0026#39;;  CommonJS\\nIf you use NodeJS, you can import Reef using the require() method with the .cjs version.\\nvar Reef = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.cjs.min.js\\u0026#39;);  AMD\\nIf you use RequireJS, SystemJS, and other AMD formats, you can import Reef with the .amd version.\\nrequirejs([\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.amd.min.js\\u0026#39;], function (Reef) { //... });  \\n2. Add an element to render your component/UI into This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works var app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too var elem = document.querySelector(\\u0026#39;#app\\u0026#39;); var app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\nYou can use old-school strings or ES6 template literals.\\n// Your template can be a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string var app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  [Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe data object is automatically encoded and passed into your template function, so that you can use it to customize your template.\\n// Some data var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Template literals give you a simple, JSX-like templating experience. If you want, you can use old-school concatenated strings for more backwards compatibility.\\n4. Render your component Render your component by calling the render() method on it.\\napp.render();  Try the demo on CodePen \\u0026rarr;\\nState Management Reef uses data reactivity to update your UI.\\nData reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\n// Create a component and render it var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } }); app.render(); // This causes component to update with \\u0026#34;Hi, universe\\u0026#34; app.data.greeting = \\u0026#39;Hi\\u0026#39;; app.data.name = \\u0026#39;Universe\\u0026#39;;  You can also update the entire data object.\\n// This will also update the UI app.data = { greeting: \\u0026#39;Hi\\u0026#39;, name: \\u0026#39;Universe\\u0026#39; };  Try data reactivity on CodePen \\u0026rarr;\\nFor better performance, multiple property updates may be batched into a single, asynchronous render. You can detect when a render has been completed using the render event hook.\\nNon-Reactive Data Sometimes, you want to update data without updating the UI.\\nYou can get an immutable copy of your data by passing it into the Reef.clone() method. This creates a non-reactive copy of your data that won\\u0026rsquo;t affect the state of your component.\\n// Create an immutable copy of the app.data var data = Reef.clone(app.data); // Update the copy // This does NOT update the app.data or render a new UI data.name = \\u0026#39;Universe\\u0026#39;;  When you\\u0026rsquo;re ready to update your component data, you can set the component\\u0026rsquo;s data property to your cloned copy.\\n// Reactively update the component data app.data = data;  Try non-reactive data on CodePen \\u0026rarr;\\nNote: You can use the Reef.clone() method to create an immutable copy of any array or object, not just your component data.\\nAdvanced Components HTML Templates Default and state-based HTML attributes You can use component data to conditionally include or change the value of HTML attributes in your template.\\nIn the example below, the checkbox is checked when agreeToTOS is true.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { agreeToTOS: true }, template: function (props) { return ` \\u0026lt;label for=\\u0026#34;tos\\u0026#34;\\u0026gt; \\u0026lt;input type=\\u0026#34;checkbox\\u0026#34; id=\\u0026#34;tos\\u0026#34; ${props.agreeToTOS ? \\u0026#39;checked\\u0026#39; : \\u0026#39;\\u0026#39;}\\u0026gt; \\u0026lt;/label\\u0026gt;`; } });  You might also want to use a default value for an attribute, but not change it based on your component\\u0026rsquo;s state. You can do that by prefixing any attribute with default in your template.\\nIn this example, option[value=\\u0026quot;hermione\\u0026quot;] has the [selected] attribute on it when first rendered, but will defer to whatever changes the user makes when diffing and updating the UI.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: {}, template: function () { return ` \\u0026lt;label for=\\u0026#34;wizards\\u0026#34;\\u0026gt;Who is the best wizard?\\u0026lt;/label\\u0026gt; \\u0026lt;select\\u0026gt; \\u0026lt;option value=\\u0026#34;harry\\u0026#34;\\u0026gt;Harry\\u0026lt;/option\\u0026gt; \\u0026lt;option value=\\u0026#34;hermione\\u0026#34; defaultSelected\\u0026gt;Hermione\\u0026lt;/option\\u0026gt; \\u0026lt;option value=\\u0026#34;neville\\u0026#34;\\u0026gt;Neville\\u0026lt;/option\\u0026gt; \\u0026lt;/select\\u0026gt;`; } });  Preventing Cross-Site Scripting (XSS) Attacks To reduce your risk of cross-site scripting (XSS) attacks, Reef automatically encodes any markup in your data before passing it into your template.\\nYou can disable this feature by setting the allowHTML option to true.\\nImportant! Do NOT do this with third-party or user-provided data. This exposes you to the risk of cross-site scripting (XSS) attacks.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;\\u0026lt;strong\\u0026gt;Hello\\u0026lt;/strong\\u0026gt;\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; }, allowHTML: true // Do NOT use with third-party/user-supplied data });  Try allowing HTML in your data on CodePen \\u0026rarr;\\nGetting the element the template is being rendered into An optional second argument is passed into the template() function: the element the template is being rendered into.\\nThis is particularly handy if you have data attributes on your element that affect what\\u0026rsquo;s rendered into the template.\\nRequires Reef 7.5 or higher.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34; data-greeting=\\u0026#34;Hello\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { name: \\u0026#39;world\\u0026#39; }, template: function (props, elem) { return `\\u0026lt;h1\\u0026gt;${elem.getAttribute(\\u0026#39;data-greeting\\u0026#39;)}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Try getting the HTML element that the template was rendered into on CodePen \\u0026rarr;\\nNested Components If you\\u0026rsquo;re managing a bigger app, you may have components nested inside other components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key in your options. You can provide a component or array of components for a value.\\nYou only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\n// Parent component var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.greeting}\\u0026lt;/h1\\u0026gt; \\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;`; } }); // Nested component var todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: { todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, template: function (props) { return ` \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; }, attachTo: app }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods on the parent component.\\nProvide an individual component or array of components as an argument.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State with Data Stores A Data Store is a special Reef object that holds reactive data you can share with multiple components.\\nAny time you update the data in your Data Store, any components that use the data will also be updated, and will render again if there are any UI changes.\\nCreate a Data Store using the new Reef.Store() constructor.\\nvar store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] } });  To use your Data Store with a component, pass it in with the store property instead of providing a data object.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { store: store, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.heading}\\u0026lt;/h1\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } });  When using a Data Store, a component will have no data of its own. All state/data updates must happen by updating the store.\\n// Add a todo item store.data.todos.push(\\u0026#39;Take a nap... zzzz\\u0026#39;);  Try creating a Data Store on CodePen \\u0026rarr;\\nSetters \\u0026amp; Getters Reef\\u0026rsquo;s reactive data makes updating your UI as simple updating an object property.\\nBut as your app scales, you may find that keeping track of what\\u0026rsquo;s updating state and causing changes to the UI becomes harder to track and maintain.\\nSetters and getters provide you with a way to control how data flows in and out of your component.\\nSetters Setters are functions that update your component or store data.\\nCreate setters by passing in an object of setter functions with the setters property in your Reef options. The first argument on a setter function is the store or component data. You can pass in as many other arguments as you\\u0026rsquo;d like.\\nvar store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, setters: { // Add a new todo item to the component \\taddTodo: function (props, todo) { props.todos.push(todo); } } });  Use setter functions by calling the do() method on your component or store. Pass in the name of setter, along with any required arguments (except for props).\\n// Add a new todo item store.do(\\u0026#39;addTodo\\u0026#39;, \\u0026#39;Take a nap... zzzz\\u0026#39;);  When a component/store has setter functions, you cannot update data directly.\\nSetter functions are the only way to make updates. This protects your component or store data from unwanted changes. The data property always returns an immutable copy of the data.\\n// This will NOT update the store.data or the UI store.data.todos.push(\\u0026#39;Take a nap... zzzz\\u0026#39;);  Try working with setter functions on CodePen \\u0026rarr;\\nGetters Getters are functions that parse data from your component or store and return a value.\\nThey\\u0026rsquo;re useful if you need to manipulate and retrieve the same data across multiple views of components. Rather than having to import helper functions, you can attach them directly to the component or store.\\nCreate getters by passing in an object of getter functions with the getters property in your Reef options. They accept the store or component data as their only argument.\\nvar store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, getters: { total: function (props) { return props.todos.length; } } });  Use getter functions by calling the get() method on your component or store. Pass in the name of getter as an argument.\\n// Get the number of todo items store.get(\\u0026#39;total\\u0026#39;);  Try working with getter functions on CodePen \\u0026rarr;\\nAsynchronous Data You can use asynchronous data (such as content from an API) in your templates.\\nSet an initial default value, make your API call, and update the data property once you get data back. This will automatically trigger a render.\\n// Create an app var app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { articles: [] }, template: function (props) { // If there are no articles  if (!props.articles.length) { return `\\u0026lt;p\\u0026gt;There are no articles.\\u0026lt;/p\\u0026gt;`; } // Otherwise, show the articles \\treturn ` \\u0026lt;ul\\u0026gt; ${props.articles.map(function (article) { return `\\u0026lt;li\\u0026gt; \\u0026lt;strong\\u0026gt;\\u0026lt;a href=\\u0026#34;#\\u0026#34;\\u0026gt;${article.title}.\\u0026lt;/a\\u0026gt;\\u0026lt;/strong\\u0026gt; ${article.body}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } }); // Fetch API data // Then, update the app data fetch(\\u0026#39;https://jsonplaceholder.typicode.com/posts\\u0026#39;).then(function (response) { return response.json(); }).then(function (data) { app.data.articles = data; });  Try create a template from asynchronous data on CodePen \\u0026rarr;\\nYou might also choose to hard-code a loading message in your markup.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;Loading...\\u0026lt;/div\\u0026gt; Event Hooks Whenever Reef updates the DOM, it emits a custom render event that you can listen for with addEventListener().\\nThe render event is emitted on the element that was updated, and bubbles, so you can also use event delegation. The event.detail property includes a copy of the data at the time that the component template was rendered.\\ndocument.addEventListener(\\u0026#39;render\\u0026#39;, function (event) { // Only run for elements with the #app ID \\tif (!event.target.matches(\\u0026#39;#app\\u0026#39;)) return; // Log the data at the time of render \\tconsole.log(event.detail); }, false);  Try the render event hook on CodePen \\u0026rarr;\\nEmitting your own custom events Reef includes a helper function, Reef.emit(), that you can use to emit your own custom events in your apps.\\nPass in the element to emit the event on and the event name as arguments. You can optionally pass in an object with event details as a third argument.\\n// Emit the \\u0026#39;partyTime\\u0026#39; event on the document element Reef.emit(document, \\u0026#39;partyTime\\u0026#39;, { msg: `It\\u0026#39;s party time!` });  Debugging By default, Reef fails silently. You can put Reef into debugging mode to expose helpful error message in the Console tab of your browser\\u0026rsquo;s Developer Tools.\\nTurn debugging mode on or off with the Reef.debug() method. Pass in true to turn it on, and false to turn it off.\\n// Turns debugging mode on Reef.debug(true); // Turns debugging mode off Reef.debug(false);  Routing Reef includes an optional router you can use to handle URL/route management with your single-page apps (SPA\\u0026rsquo;s).\\nFeatures  Automatically renders your Reef components whenever the route changes. Works with any link element. Unlike bigger frameworks, you don\\u0026rsquo;t need custom routing components. Baked-in accessibility. Reef\\u0026rsquo;s router automatically handles focus management and title updates. Supports real URL paths, with an optional hashbang pattern (#!) fallback. Weighs just 2kb minified and gzipped.  Installation Reef Router is just as easy to install as Reef itself. Reef must also be installed as a dependency.\\nReef Router requires Reef v7.1.0 or higher.\\nCDN\\n\\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs/dist/router.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; ES Modules\\nimport Reef from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.es.min.js\\u0026#39;; import \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs/dist/router.es.min.js\\u0026#39;;   More ways to install Reef Direct Download\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;script src=\\u0026#34;path/to/router.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; NPM\\nimport Reef from \\u0026#39;reefjs\\u0026#39;; import \\u0026#39;reefjs/router\\u0026#39;;  CommonJS\\nvar Reef = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.cjs.min.js\\u0026#39;); var Router = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs/dist/router.cjs.min.js\\u0026#39;);  AMD\\nrequirejs([\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs/dist/reef.amd.min.js\\u0026#39;, \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs/dist/router.amd.min.js\\u0026#39;], function (Reef) { //... });  \\nGetting Started Step 1: Create your links\\nNo custom components required. Any link element with an href will work.\\n\\u0026lt;ul\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/\\u0026#34;\\u0026gt;Home\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/about\\u0026#34;\\u0026gt;About\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/contact\\u0026#34;\\u0026gt;Contact\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;/ul\\u0026gt; Step 2: Define your routes\\nCreate a new Reef.Router() to define your routes.\\nEvery route requires a title and url. You can add any additional properties that you want (for example, an id for the route). You can use * as a url to catch any unmatched URLs.\\nvar router = new Reef.Router({ routes: [ { id: \\u0026#39;home\\u0026#39;, title: \\u0026#39;Home\\u0026#39;, url: \\u0026#39;/\\u0026#39; }, { id: \\u0026#39;about\\u0026#39;, title: \\u0026#39;About\\u0026#39;, url: \\u0026#39;/about\\u0026#39; }, { id: \\u0026#39;contact\\u0026#39;, title: \\u0026#39;Contact Us\\u0026#39;, url: \\u0026#39;/contact\\u0026#39; } ] });  Step 3: Associate your router with one or more components\\nFor any Reef component that should be updated when the route changes, add a router property and associate your router component with it.\\nDetails about the current route are automatically passed into the template function as a second argument. By default, for unmatched routes the route argument will have a value of null.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { router: router, data: { greeting: \\u0026#39;hello!\\u0026#39; }, template: function (props, route) { return ` \\u0026lt;h1\\u0026gt;${route.title}\\u0026lt;/h1\\u0026gt; \\u0026lt;p\\u0026gt;${props.greeting}\\u0026lt;/p\\u0026gt;`; } });  Note: when using a router, the element that the template was rendered into becomes the third argument on the template() function.\\nAccessibility Any time the route changes, any associated components automatically re-render.\\nThe document.title is also updated, and focus is shifted to the primary heading on the page (or an anchor element if scrolling to an anchored location).\\nFocus rings on headings Headings and anchor locations will appear with a focus ring around them, which you may find visually unappealing.\\nElements that don\\u0026rsquo;t normally receive focus are given a tabindex if -1 to make them focusable with JS. You can remove the focus ring by styling [tabindex=\\u0026quot;-1\\u0026quot;].\\n[tabindex=\\u0026#34;-1\\u0026#34;] { outline: 0; } Note: you should NOT remove focus styles from elements that are normally focusable.\\nAdvanced Routing Getting parameters from routes You can include variable parameters in your URLs, either in the path itself or as query or search parameters.\\nReef Router will add them to the route object that gets passed into your template(). Path parameters are included under the params property, and query or search parameters are included under the search property.\\n\\u0026lt;ul\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/\\u0026#34;\\u0026gt;Home\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/account/tom?photo=true\\u0026#34;\\u0026gt;My Account\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;/ul\\u0026gt;var router = new Reef.Router({ routes: [ { id: \\u0026#39;home\\u0026#39;, title: \\u0026#39;Home\\u0026#39;, url: \\u0026#39;/\\u0026#39; }, { id: \\u0026#39;user-account\\u0026#39;, title: \\u0026#39;User Account\\u0026#39;, url: \\u0026#39;/account/:user\\u0026#39; } ] }); // In this example: // route.params.user will be \\u0026#34;tom\\u0026#34; // route.search.photo will be \\u0026#34;true\\u0026#34; var app = new Reef(\\u0026#39;#app\\u0026#39;, { router: router, data: { greeting: \\u0026#39;hello!\\u0026#39; }, template: function (props, route) { return ` \\u0026lt;h1\\u0026gt;${route.title}\\u0026lt;/h1\\u0026gt; \\u0026lt;p\\u0026gt;${props.greeting}${route.params.user}\\u0026lt;/p\\u0026gt; ${route.search.photo ? `\\u0026lt;p\\u0026gt; \\u0026lt;img alt=\\u0026#34;A photo of ${route.params.user}\\u0026#34; src=\\u0026#34;/img/${route.params.user}.jpg\\u0026#34;\\u0026gt; \\u0026lt;/p\\u0026gt;` : \\u0026#39;\\u0026#39;}`; } });  Nested routes Reef Router supports nested routes out-of-the-box.\\nThe order does not matter. Reef Router will check deeper routes for matches first.\\nvar router = new Reef.Router({ routes: [ { id: \\u0026#39;home\\u0026#39;, title: \\u0026#39;Home\\u0026#39;, url: \\u0026#39;/\\u0026#39; }, { id: \\u0026#39;account\\u0026#39;, title: \\u0026#39;Account\\u0026#39;, url: \\u0026#39;/account/\\u0026#39; }, { id: \\u0026#39;user-account\\u0026#39;, title: \\u0026#39;User Account\\u0026#39;, url: \\u0026#39;/account/:user\\u0026#39; }, { id: \\u0026#39;user-password\\u0026#39;, title: \\u0026#39;Change Password\\u0026#39;, url: \\u0026#39;/account/:user/password\\u0026#39; } ] });  Redirects As your app grows, routes may change. You can setup redirects from one route to another.\\nWhen creating the route, create the url property as normal, and add a redirect property with the route that the URL should point to.\\nvar router = new Reef.Router({ routes: [ { id: \\u0026#39;contact\\u0026#39;, title: \\u0026#39;Contact\\u0026#39;, url: \\u0026#39;/contact/\\u0026#39; }, { url: \\u0026#39;/contact-us/\\u0026#39;, redirect: \\u0026#39;/contact/\\u0026#39; } ] });  The redirect property can also be a function that returns a string.\\nThe function automatically receive the existing route object, with URL and search parameters, as an argument.\\nvar router = new Reef.Router({ routes: [ { id: \\u0026#39;user-account\\u0026#39;, title: \\u0026#39;User Account\\u0026#39;, url: \\u0026#39;/account/:user\\u0026#39; }, { url: \\u0026#39;/my-account/:user\\u0026#39;, redirect: function (route) { return `/account/${route.params.user}/` } }, ] });  Options \\u0026amp; Settings In addition to your routes, Reef Router accepts a few options you can use to customize how the router behaves.\\nvar router = new Reef.Router({ root: \\u0026#39;\\u0026#39;, // The root URL for your app, if using a subdirectory \\ttitle: \\u0026#39;{{title}}\\u0026#39;, // The pattern to use for the page title. {{title}} will be replaced with the actual title \\tuseHash: false // If true, uses a hashbang (#!) pattern instead of true URL paths });  The title property can be a string or a function that returns a string.\\nThe useHash property is automatically set to true in browsers that don\\u0026rsquo;t support the history.pushState() method, and local file: pages.\\nExamples The app lives at my-site.com/my-app/.\\nvar router = new Reef.Router({ root: \\u0026#39;/my-app\\u0026#39; });  The document.title will always have | My App after it.\\nvar router = new Reef.Router({ title: \\u0026#39;{{title}} | My App\\u0026#39; });  The document.title will always have | My App after it except on the homepage, where it\\u0026rsquo;s just My App.\\nvar router = new Reef.Router({ title: function (route) { if (route \\u0026amp;\\u0026amp; route.id === \\u0026#39;home\\u0026#39;) { return \\u0026#39;My App\\u0026#39;; } return \\u0026#39;{{title}} | My App\\u0026#39;; } });  Always use the hashbang pattern.\\nvar router = new Reef.Router({ useHash: true });  API Reef.Router exposes a few public methods you can use in your scripts.\\naddRoutes() Add routes to an existing route. Accepts an array of routes, or an individual route object.\\n// Add an individual route router.addRoutes({ id: \\u0026#39;sale\\u0026#39;, title: \\u0026#39;Holiday Sale!\\u0026#39;, url: \\u0026#39;/sale\\u0026#39; }); // Add multiple routes router.addRoutes([ { id: \\u0026#39;about\\u0026#39;, title: \\u0026#39;About\\u0026#39;, url: \\u0026#39;/about\\u0026#39; }, { id: \\u0026#39;contact\\u0026#39;, title: \\u0026#39;Contact Us\\u0026#39;, url: \\u0026#39;/contact\\u0026#39; } ]);  navigate() Programmatically navigate to a URL. Pass in the URL as an argument.\\n// Go to the /about page router.navigate(\\u0026#39;/about\\u0026#39;);  addComponent() Associate a component with the router for automatic rendering.\\n// Add the app component router.addComponent(app);  current The current property will return the details object for the current route.\\n// Get the current route details router.current;  Routing Events Reef Router emits two custom events on the window whenever a route change happens.\\n beforeRouteUpdated fires before the route is changed. It includes the current and next routes as properties under event.detail routeUpdated fires after the route has been changed. It includes the current and previous routes as properties under event.detail.  // Run a callback before the route changes // Useful for tearing down scripts that won\\u0026#39;t be needed on the next view window.addEventListener(\\u0026#39;beforeRouteUpdated\\u0026#39;, function (event) { // The route that\\u0026#39;s about to the change \\tvar current = event.detail.current; // The new route \\tvar next = event.detail.next; }); // Run a callback after the route changes // Useful for loading or re-initializing scripts window.addEventListener(\\u0026#39;routeUpdated\\u0026#39;, function (event) { // The new route \\tvar current = event.detail.current; // The previous route \\tvar previous = event.detail.previous; });  Kudos Reef Router\\u0026rsquo;s URL path matching and parameter extraction is adapted from Navigo by Krasimir Tsonev.\\nClick handling is adapted from pages.js by Vision Media.\\nDemos Want to see Reef in action? Here are some demos and examples you can play with.\\n Clock Mirror Typing Pomodoro Timer Stopwatch Todo List Whack-a-Mole Game Articles from an API  Browser Compatibility Reef works in all modern browsers, and IE 9 and above.\\nFor IE support, you need to either...\\n Use the .polyfill build of Reef, or Include your own polyfills for Proxies and the CustomEvent() object, or Transpile your code into ES5 with BabelJS.  License The code is available under the MIT License.\\n\",\"title\":\"Reef v7\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v7/\"},{\"content\":\" A lightweight library for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features  Weighs just 3kb minified and gzipped, with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a \\u0026lt;script\\u0026gt; element or ES module import\\u0026mdash;no command line or transpiling required. Uses DOM diffing to update only the things that have changed. Has Redux/Vuex-like data stores, setters and getters baked right in. Automatically encodes markup in your data to protect you from cross-site scripting (XSS) attacks. Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Supported all the way back to IE9.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef only updates things that have changed instead of clobbering the DOM and removing focus from your form fields. It also automatically renders a new UI when your data updates, and helps protect you from XSS attacks.\\nIf you\\u0026rsquo;re craving a simpler, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site Reef works without any build step.\\nThe CDN is the fastest and simplest way to get started, but you can use importable modules or a direct download if you\\u0026rsquo;d prefer.\\n\\u0026lt;!-- Get the latest major version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; Reef uses semantic versioning. You can grab a major, minor, or patch version from the CDN with the @1.2.3 syntax. You can find all available versions under releases.\\n More ways to install Reef ES Modules\\nReef also supports modern browsers and module bundlers (like Rollup, Webpack, Snowpack, and so on) using the ES modules import syntax. Use the .es version.\\nimport Reef from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.es.min.js\\u0026#39;;  NPM\\nYou can also use NPM (or your favorite package manager). First, install with NPM.\\nnpm install reefjs --save Then import the package.\\nimport Reef from \\u0026#39;reefjs\\u0026#39;;  CommonJS\\nIf you use NodeJS, you can import Reef using the require() method with the .cjs version.\\nlet Reef = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.cjs.min.js\\u0026#39;);  AMD\\nIf you use RequireJS, SystemJS, and other AMD formats, you can import Reef with the .amd version.\\nrequirejs([\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.amd.min.js\\u0026#39;], function (Reef) { //... });  Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\n2. Add an element to render your component/UI into This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works let app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too let elem = document.querySelector(\\u0026#39;#app\\u0026#39;); let app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\n// Your template can be a string let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  [Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe data object is automatically encoded and passed into your template function, so that you can use it to customize your template.\\n// Some data let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Template literals give you a simple, JSX-like templating experience.\\n4. Render your component Render your component by calling the render() method on it.\\napp.render();  Try the demo on CodePen \\u0026rarr;\\nState Management Reef uses data reactivity to update your UI.\\nData reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\n// Create a component and render it let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } }); app.render(); // This causes component to update with \\u0026#34;Hi, universe\\u0026#34; app.data.greeting = \\u0026#39;Hi\\u0026#39;; app.data.name = \\u0026#39;Universe\\u0026#39;;  You can also update the entire data object.\\n// This will also update the UI app.data = { greeting: \\u0026#39;Hi\\u0026#39;, name: \\u0026#39;Universe\\u0026#39; };  Try data reactivity on CodePen \\u0026rarr;\\nFor better performance, multiple property updates may be batched into a single, asynchronous render. You can detect when a render has been completed using the reef:render event hook.\\nNon-Reactive Data Sometimes, you want to update data without updating the UI.\\nYou can get an immutable copy of your data by passing it into the Reef.clone() method. This creates a non-reactive copy of your data that won\\u0026rsquo;t affect the state of your component or cause a UI update.\\n// Create an immutable copy of the app.data let data = Reef.clone(app.data); // Update the copy // This does NOT update the app.data or render a new UI data.name = \\u0026#39;Universe\\u0026#39;;  When you\\u0026rsquo;re ready to update your component data, you can set the component\\u0026rsquo;s data property to your cloned copy.\\n// Reactively update the component data app.data = data;  Try non-reactive data on CodePen \\u0026rarr;\\nNote: You can use the Reef.clone() method to create an immutable copy of any array or object, not just your component data.\\nAdvanced Components As your project gets bigger, the way you manage components and data may need to grow with it. Reef has some options to help make things a little easier.\\nHTML Templates Default and state-based HTML attributes You can use component data to conditionally include or change the value of HTML attributes in your template.\\nUse the reef-checked, reef-selected, and reef-value attributes to dynamically control the checked, selected, and value attributes, respectively. Use a falsy value when the item should not be checked or selected.\\nIn the example below, the checkbox is checked when agreeToTOS is true.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { agreeToTOS: true }, template: function (props) { return ` \\u0026lt;label\\u0026gt; \\u0026lt;input type=\\u0026#34;checkbox\\u0026#34; reef-checked=\\u0026#34;${agreeToTOS}\\u0026#34;\\u0026gt; \\u0026lt;/label\\u0026gt;`; } });  You might also want to use a default value when an element initially renders, but defer to any changes the user makes after that.\\nYou can do that with the reef-default-checked, reef-default-selected, and reef-default-value attributes.\\nIn this example, Hermione has the [selected] attribute on it when first rendered, but will defer to whatever changes the user makes when diffing and updating the UI.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return ` \\u0026lt;label for=\\u0026#34;wizards\\u0026#34;\\u0026gt;Who is the best wizard?\\u0026lt;/label\\u0026gt; \\u0026lt;select\\u0026gt; \\u0026lt;option\\u0026gt;Harry\\u0026lt;/option\\u0026gt; \\u0026lt;option reef-default-selected\\u0026gt;Hermione\\u0026lt;/option\\u0026gt; \\u0026lt;option\\u0026gt;Neville\\u0026lt;/option\\u0026gt; \\u0026lt;/select\\u0026gt;`; } });  Try controlling form attributes on CodePen \\u0026rarr;\\nPreventing Cross-Site Scripting (XSS) Attacks To reduce your risk of cross-site scripting (XSS) attacks, Reef automatically encodes any markup in your data before passing it into your template.\\nYou can disable this feature by setting the allowHTML option to true.\\nImportant! Do NOT do this with third-party or user-provided data. This exposes you to the risk of cross-site scripting (XSS) attacks.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;\\u0026lt;strong\\u0026gt;Hello\\u0026lt;/strong\\u0026gt;\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; }, allowHTML: true // Do NOT use with third-party/user-supplied data });  Try allowing HTML in your data on CodePen \\u0026rarr;\\nGetting the element the template is being rendered into An optional second argument is passed into the template() function: the element the template is being rendered into.\\nThis is particularly handy if you have data attributes on your element that affect what\\u0026rsquo;s rendered into the template.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34; data-greeting=\\u0026#34;Hello\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { name: \\u0026#39;world\\u0026#39; }, template: function (props, elem) { return `\\u0026lt;h1\\u0026gt;${elem.getAttribute(\\u0026#39;data-greeting\\u0026#39;)}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Try getting the HTML element that the template was rendered into on CodePen \\u0026rarr;\\nNested Components If you\\u0026rsquo;re managing a bigger app, you may have components nested inside other components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key in your options object. You can provide a component or array of components for a value.\\nYou only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\n// Parent component let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.greeting}\\u0026lt;/h1\\u0026gt; \\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;`; } }); // Nested component let todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: { todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, template: function (props) { return ` \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; }, attachTo: app }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods on the parent component.\\nProvide an individual component or array of components as an argument.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State with Data Stores A Data Store is a special Reef object that holds reactive data you can share with multiple components.\\nAny time you update the data in your Data Store, any components that use the data will also be updated, and will render again if there are any UI changes.\\nCreate a Data Store using the new Reef.Store() constructor.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] } });  To use your Data Store with a component, pass it in with the store property instead of providing a data object.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { store: store, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.heading}\\u0026lt;/h1\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } });  When using a Data Store, a component will have no data of its own. All state/data updates must happen by updating the store.\\n// Add a todo item store.data.todos.push(\\u0026#39;Take a nap... zzzz\\u0026#39;);  Try creating a Data Store on CodePen \\u0026rarr;\\nSetters \\u0026amp; Getters Reef\\u0026rsquo;s reactive data makes updating your UI as simple updating an object property.\\nBut as your app scales, you may find that keeping track of what\\u0026rsquo;s updating state and causing changes to the UI becomes harder to track and maintain.\\nSetters and getters provide you with a way to control how data flows in and out of your component.\\nSetters Setters are functions that update your component or store data.\\nCreate setters by passing in an object of setter functions with the setters property in your options object. The first parameter on a setter function is the store or component data. You can add as many other parameters as you\\u0026rsquo;d like.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, setters: { // Add a new todo item to the component \\taddTodo: function (props, todo) { props.todos.push(todo); } } });  Use setter functions by calling the do() method on your component or store. Pass in the name of the setter, along with any required arguments (except for props).\\n// Add a new todo item store.do(\\u0026#39;addTodo\\u0026#39;, \\u0026#39;Take a nap... zzzz\\u0026#39;);  When a component or store has setter functions, they become the only way to update app or store data.\\nThis protects your component or store data from unwanted changes. The data property always returns an immutable copy.\\n// This will NOT update the store.data or the UI store.data.todos.push(\\u0026#39;Take a nap... zzzz\\u0026#39;);  Try working with setter functions on CodePen \\u0026rarr;\\nGetters Getters are functions that parse data from your component or store and return a value.\\nThey\\u0026rsquo;re useful if you need to manipulate and retrieve the same data across multiple views of components. Rather than having to import helper functions, you can attach them directly to the component or store.\\nCreate getters by passing in an object of getter functions with the getters property in your options object. The first parameter on a getter function is the store or component data. You can add as many other parameters as you\\u0026rsquo;d like.\\nSupport for parameters besides props requires version 8.2.0 or higher.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, getters: { total: function (props) { return props.todos.length; } } });  Use getter functions by calling the get() method on your component or store. Pass in the name of getter, along with any required arguments (except for props).\\n// Get the number of todo items store.get(\\u0026#39;total\\u0026#39;);  Try working with getter functions on CodePen \\u0026rarr;\\nAsynchronous Data You can use asynchronous data (such as content from an API) in your templates.\\nSet an initial default value, make your API call, and update the data property once you get data back. This will automatically trigger a render.\\n// Create an app let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { articles: [] }, template: function (props) { // If there are no articles  if (!props.articles.length) { return `\\u0026lt;p\\u0026gt;There are no articles.\\u0026lt;/p\\u0026gt;`; } // Otherwise, show the articles \\treturn ` \\u0026lt;ul\\u0026gt; ${props.articles.map(function (article) { return `\\u0026lt;li\\u0026gt; \\u0026lt;strong\\u0026gt;\\u0026lt;a href=\\u0026#34;#\\u0026#34;\\u0026gt;${article.title}.\\u0026lt;/a\\u0026gt;\\u0026lt;/strong\\u0026gt; ${article.body}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } }); // Fetch API data // Then, update the app data fetch(\\u0026#39;https://jsonplaceholder.typicode.com/posts\\u0026#39;).then(function (response) { return response.json(); }).then(function (data) { app.data.articles = data; });  Try create a template from asynchronous data on CodePen \\u0026rarr;\\nYou might also choose to hard-code a loading message in your markup.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;Loading...\\u0026lt;/div\\u0026gt; Debugging By default, Reef fails silently. You can put Reef into debug mode to expose helpful error message in the Console tab of your browser\\u0026rsquo;s Developer Tools.\\nTurn debug mode on or off with the Reef.debug() method. Pass in true to turn it on, and false to turn it off.\\n// Turns debug mode on Reef.debug(true); // Turns debug mode off Reef.debug(false);  Routing Reef includes two optional ways to handle URL/route management in your apps:\\n Router for single-page apps. Snorkel for speedier multi-page apps.  Both have been designed to integrate deeply with Reef, and share the same simple, lightweight approach.\\nRouter Reef Router is an optional router that you can use to handle URL/route management with your single-page apps (SPA\\u0026rsquo;s).\\n Automatically renders your Reef components whenever the route changes. Works with any link element. Unlike bigger frameworks, you don\\u0026rsquo;t need custom routing components. Baked-in accessibility. Reef\\u0026rsquo;s router automatically handles focus management and title updates. Supports real URL paths, with an optional hashbang pattern (#!) fallback. Compatible with nested routing structures. Weighs just 2.7kb minified and gzipped.  Installation Reef Router is just as easy to install as Reef itself. Reef must also be installed as a dependency.\\nThe CDN is the fastest and simplest way to get started, but you can use importable modules or a direct download if you\\u0026rsquo;d prefer.\\n\\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@8/dist/router.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt;  More ways to install Reef Router When used with a module system, you must explicitly associate Reef with the router with the Reef.use() method.\\nES Modules\\nimport Reef from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.es.min.js\\u0026#39;; import ReefRouter from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/router.es.min.js\\u0026#39;; Reef.use(ReefRouter);  NPM\\nimport Reef from \\u0026#39;reefjs\\u0026#39;; import ReefRouter from \\u0026#39;reefjs/router\\u0026#39;; Reef.use(ReefRouter);  CommonJS\\nlet Reef = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.cjs.min.js\\u0026#39;); let ReefRouter = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/router.cjs.min.js\\u0026#39;); Reef.use(ReefRouter);  AMD\\nrequirejs([ \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.amd.min.js\\u0026#39;, \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/router.amd.min.js\\u0026#39; ],function (Reef, ReefRouter) { Reef.use(ReefRouter); });  Direct Download\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;script src=\\u0026#34;path/to/router.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\nGetting Started Step 1: Create your links\\nNo custom components required. Any link element with an href will work.\\n\\u0026lt;ul\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/\\u0026#34;\\u0026gt;Home\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/about\\u0026#34;\\u0026gt;About\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/contact\\u0026#34;\\u0026gt;Contact\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;/ul\\u0026gt; Step 2: Define your routes\\nCreate a new ReefRouter() instance to define your routes.\\nEvery route requires a title and url. The title can be a string, or a function that returns a string and accepts the route object as an argument. You can add any additional properties that you want (for example, an id for the route).\\nOptionally, you can use * as a url to catch any unmatched URLs.\\nlet router = new ReefRouter({ routes: [ { id: \\u0026#39;home\\u0026#39;, title: \\u0026#39;Home\\u0026#39;, url: \\u0026#39;/\\u0026#39; }, { id: \\u0026#39;about\\u0026#39;, title: function (route) { return \\u0026#39;About\\u0026#39;; }, url: \\u0026#39;/about\\u0026#39; }, { id: \\u0026#39;contact\\u0026#39;, title: \\u0026#39;Contact Us\\u0026#39;, url: \\u0026#39;/contact\\u0026#39; } ] });  Step 3: Associate your router with one or more components\\nFor any Reef component that should be updated when the route changes, add a router property and use your router component as the value.\\nDetails about the current route are automatically passed into the template function as a second argument. If you don\\u0026rsquo;t provide a catchall (url: '*') route, an unmatched route will have a value of null.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { router: router, data: { greeting: \\u0026#39;hello!\\u0026#39; }, template: function (props, route) { return ` \\u0026lt;h1\\u0026gt;${route.title}\\u0026lt;/h1\\u0026gt; \\u0026lt;p\\u0026gt;${props.greeting}\\u0026lt;/p\\u0026gt;`; } });  Note: when using a router, the element that the template was rendered into becomes the third argument on the template() function.\\nAccessibility Any time the route changes, any associated components automatically re-render.\\nThe document.title is also updated, and focus is shifted to the primary heading on the page (or an anchor element if scrolling to an anchored location).\\nFocus rings on headings Headings and anchor locations will appear with a focus ring around them, which you may find visually unappealing.\\nElements that don\\u0026rsquo;t normally receive focus are given a tabindex of -1 to make them focusable with JS. You can remove the focus ring by styling [tabindex=\\u0026quot;-1\\u0026quot;].\\n[tabindex=\\u0026#34;-1\\u0026#34;] { outline: 0; } Note: you should NOT remove focus styles from elements that are natively focusable.\\nServer Configuration Single page apps works great when you visit the homepage first. But when someone visits one of your routes directly or hits reload, they get a 404 page.\\nTo fix that, you need to configure your server to point all pages to your index.html file. Paul Sherman has a great deep-dive on how that all works titled Single-Page Applications and the Server.\\nHere\\u0026rsquo;s an .htaccess file example for apache servers.\\n\\u0026lt;IfModule mod_rewrite.c\\u0026gt; RewriteEngine On RewriteRule ^index\\\\.html$ - [L] RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule . index.html [L] \\u0026lt;/IfModule\\u0026gt; And here\\u0026rsquo;s what it might look like in express (taken from the Reach Router docs).\\nconst path = require(\\u0026#39;path\\u0026#39;); const express = require(\\u0026#39;express\\u0026#39;); const app = new express() // requests for static files in the \\u0026#34;public\\u0026#34; directory // like JavaScript, CSS, images will be served app.use(express.static(\\u0026#39;public\\u0026#39;)); // Every other request will send the index.html file that // contains your application app.use(\\u0026#39;*\\u0026#39;, function(req, resp) { resp.sendFile(\\u0026#39;/public/index.html\\u0026#39;); }); app.listen(\\u0026#39;8000\\u0026#39;);  Advanced Routing Getting parameters from routes You can include variable parameters in your URLs, either in the path itself or as query or search parameters.\\nReef Router will add them to the route object that gets passed into your template(). Path parameters are included under the params property, and query/search parameters are included under the search property.\\n\\u0026lt;ul\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/\\u0026#34;\\u0026gt;Home\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/account/tom?photo=true\\u0026#34;\\u0026gt;My Account\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;/ul\\u0026gt;let router = new ReefRouter({ routes: [ { id: \\u0026#39;home\\u0026#39;, title: \\u0026#39;Home\\u0026#39;, url: \\u0026#39;/\\u0026#39; }, { id: \\u0026#39;user-account\\u0026#39;, title: function (route) { return `User Account: ${route.params.user}`; }, url: \\u0026#39;/account/:user\\u0026#39; } ] }); // In this example: // route.params.user will be \\u0026#34;tom\\u0026#34; // route.search.photo will be \\u0026#34;true\\u0026#34; let app = new Reef(\\u0026#39;#app\\u0026#39;, { router: router, data: { greeting: \\u0026#39;hello!\\u0026#39; }, template: function (props, route) { return ` \\u0026lt;h1\\u0026gt;${route.title}\\u0026lt;/h1\\u0026gt; \\u0026lt;p\\u0026gt;${props.greeting}${route.params.user}\\u0026lt;/p\\u0026gt; ${route.search.photo ? `\\u0026lt;p\\u0026gt; \\u0026lt;img alt=\\u0026#34;A photo of ${route.params.user}\\u0026#34; src=\\u0026#34;/img/${route.params.user}.jpg\\u0026#34;\\u0026gt; \\u0026lt;/p\\u0026gt;` : \\u0026#39;\\u0026#39;}`; } });  Nested routes Reef Router supports nested routes out-of-the-box.\\nThe order does not matter. Reef Router will check deeper routes for matches first.\\nlet router = new ReefRouter({ routes: [ { id: \\u0026#39;home\\u0026#39;, title: \\u0026#39;Home\\u0026#39;, url: \\u0026#39;/\\u0026#39; }, { id: \\u0026#39;account\\u0026#39;, title: \\u0026#39;Account\\u0026#39;, url: \\u0026#39;/account/\\u0026#39; }, { id: \\u0026#39;user-account\\u0026#39;, title: \\u0026#39;User Account\\u0026#39;, url: \\u0026#39;/account/:user\\u0026#39; }, { id: \\u0026#39;user-password\\u0026#39;, title: \\u0026#39;Change Password\\u0026#39;, url: \\u0026#39;/account/:user/password\\u0026#39; } ] });  Redirects As your app grows, routes may change. You can setup redirects from one route to another.\\nWhen creating the route, create the url property as normal, and add a redirect property with the route that the URL should point to.\\nlet router = new ReefRouter({ routes: [ { id: \\u0026#39;contact\\u0026#39;, title: \\u0026#39;Contact\\u0026#39;, url: \\u0026#39;/contact/\\u0026#39; }, { url: \\u0026#39;/contact-us/\\u0026#39;, redirect: \\u0026#39;/contact/\\u0026#39; } ] });  The redirect property can also be a function that returns a string.\\nThe function automatically receives the existing route object, with URL and search parameters, as an argument.\\nlet router = new ReefRouter({ routes: [ { id: \\u0026#39;user-account\\u0026#39;, title: \\u0026#39;User Account\\u0026#39;, url: \\u0026#39;/account/:user\\u0026#39; }, { url: \\u0026#39;/my-account/:user\\u0026#39;, redirect: function (route) { return `/account/${route.params.user}/`; } }, ] });  Options \\u0026amp; Settings In addition to your routes, Reef Router accepts a few options you can use to customize how the router behaves.\\nlet router = new ReefRouter({ root: \\u0026#39;\\u0026#39;, // The root URL for your app, if using a subdirectory \\t// The pattern to use for the document.title \\t// Receives the current route and route.title as arguments \\ttitle: function (route, title) { if (route.url === \\u0026#39;/\\u0026#39;) return \\u0026#39;My Awesome App\\u0026#39;; return `${title}| My Awesome App`; }, useHash: false // If true, uses a hashbang (#!) pattern instead of true URL paths });  The title property can be a string or a function that returns a string. As a function, it receives the current route and the route.title as arguments.\\nThe useHash property is automatically set to true for local file: pages.\\nExamples The app lives at my-site.com/my-app/.\\nlet router = new ReefRouter({ root: \\u0026#39;/my-app\\u0026#39; });  The document.title will always be the router.title.\\nlet router = new ReefRouter({ title: function (route, title) { return title; } });  The document.title will always have | My Awesome App after it, except on the homepage, where it\\u0026rsquo;s just My Awesome App.\\nlet router = new ReefRouter({ title: function (route, title) { if (route.url === \\u0026#39;/\\u0026#39;) return \\u0026#39;My Awesome App\\u0026#39;; return `${title}| My Awesome App`; }, });  Always use the hashbang pattern.\\nlet router = new ReefRouter({ useHash: true });  Kudos! Reef Router\\u0026rsquo;s URL path matching and parameter extraction is adapted from Navigo by Krasimir Tsonev. Click handling is adapted from pages.js by Vision Media.\\nSnorkel Snorkel merges the speed of SPAs with the simplicity of multi-page apps.\\nHow it works. You create separate HTML files for your app, and add links to them just like you normally would. Snorkel detects clicks on those links, fetches the HTML with ajax, and updates the UI without causing a page reload.\\n Automatically renders your Reef components whenever the view changes. No need to specify routes. Just build your multi-page app like you normally would. Baked-in accessibility. Scroll position is reset on each view change, and Snorkel\\u0026rsquo;s UI updates are automatically announced by screen readers. Weighs just 2.3kb minified and gzipped.  Installation Snorkel is just as easy to install as Reef itself. Reef must also be installed as a dependency.\\nThe CDN is the fastest and simplest way to get started, but you can use importable modules or a direct download if you\\u0026rsquo;d prefer.\\nSnorkel requires version 8.2.0 or higher of Reef.\\n\\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@8/dist/snorkel.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt;  More ways to install Snorkel When used with a module system, you must explicitly associate Reef with Snorkel with the Reef.use() method.\\nES Modules\\nimport Reef from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.es.min.js\\u0026#39;; import ReefSnorkel from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/snorkel.es.min.js\\u0026#39;; Reef.use(ReefSnorkel);  NPM\\nimport Reef from \\u0026#39;reefjs\\u0026#39;; import ReefSnorkel from \\u0026#39;reefjs/snorkel\\u0026#39;; Reef.use(ReefSnorkel);  CommonJS\\nvar Reef = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.cjs.min.js\\u0026#39;); var ReefSnorkel = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/snorkel.cjs.min.js\\u0026#39;); Reef.use(ReefSnorkel);  AMD\\nrequirejs([ \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/reef.amd.min.js\\u0026#39;, \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@8/dist/snorkel.amd.min.js\\u0026#39; ],function (Reef, ReefSnorkel) { Reef.use(ReefSnorkel); });  Direct Download\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\u0026lt;script src=\\u0026#34;path/to/snorkel.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\nGetting Started Once Snorkel is installed, activate it by creating a new ReefSnorkel() instance.\\nlet snorkel = new ReefSnorkel();  For any Reef component that should be updated when the route changes, add a router property and use the Snorkel instance as the value.\\nvar app = new Reef(\\u0026#39;#app\\u0026#39;, { router: snorkel, data: { greeting: \\u0026#39;hello!\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;Good morning\\u0026lt;/h1\\u0026gt; \\u0026lt;p\\u0026gt;${props.greeting}\\u0026lt;/p\\u0026gt;`; } });  What happens on a URL update? Not much, actually.\\n The entire document.body is replaced. The \\u0026lt;head\\u0026gt; element is diffed, and changes are selectively applied. The URL is updated using the history.pushState() method. Any associated Reef components are rendered.  Advanced Features Ignoring Links By default, Snorkel works on all links that point to pages on the same domain as your app automatically.\\nYou can tell Snorkel to ignore certain links by adding the [snorkel-ignore] attribute to them or one of their parent elements.\\n\\u0026lt;!-- This link will be ignored --\\u0026gt; \\u0026lt;a snorkel-ignore href=\\u0026#34;/about\\u0026#34;\\u0026gt;About Us\\u0026lt;/a\\u0026gt; \\u0026lt;!-- All of these links will be, too --\\u0026gt; \\u0026lt;nav snorkel-ignore\\u0026gt; \\u0026lt;ul\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/\\u0026#34;\\u0026gt;Home\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/about\\u0026#34;\\u0026gt;About\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/contact\\u0026#34;\\u0026gt;Contact\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;/ul\\u0026gt; \\u0026lt;/nav\\u0026gt; You can activate Snorkel on a specific link while ignoring others by adding the [snorkel] attribute.\\n\\u0026lt;!-- All of these links will be ignored, except for /about --\\u0026gt; \\u0026lt;nav snorkel-ignore\\u0026gt; \\u0026lt;ul\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/\\u0026#34;\\u0026gt;Home\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a snorkel href=\\u0026#34;/about\\u0026#34;\\u0026gt;About\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;li\\u0026gt;\\u0026lt;a href=\\u0026#34;/contact\\u0026#34;\\u0026gt;Contact\\u0026lt;/a\\u0026gt;\\u0026lt;/li\\u0026gt; \\u0026lt;/ul\\u0026gt; \\u0026lt;/nav\\u0026gt; You can also disable Snorkel globally by passing in an object of options, and setting autoLinks to false. Then, only links with the [snorkel] attribute on them will use Snorkel.\\nlet snorkel = new ReefSnorkel({ autoLinks: false });  Replacing a view instead of creating a new one By default, Snorkel creates a new entry in a browser\\u0026rsquo;s navigation history. Users can go back to the previous page with the browser\\u0026rsquo;s back button.\\nIf you add the [snorkel=\\u0026quot;replace\\u0026quot;] attribute to a link (or parent element of a link), the new page will replace the existing entry in the navigation history instead of creating a new one.\\n\\u0026lt;!-- This link will replace the current URL in browser history --\\u0026gt; \\u0026lt;a snorkel=\\u0026#34;replace\\u0026#34; href=\\u0026#34;/about\\u0026#34;\\u0026gt;About Us\\u0026lt;/a\\u0026gt; Caching views in history To improve performance when navigating back through browser history, Snorkel caches the previous 50 pages for an hour.\\nThese are not used when a link is clicked, only when using a browser\\u0026rsquo;s forward/back buttons. On link clicks, fresh content is always fetched.\\nYou can change how many pages are cached, and for how long, using the cacheSize and cacheTime properties on the options object. You can also disable caching entirely by seeing the cache property to false.\\n// Change the default cache size and duration let snorkel = new ReefSnorkel({ cacheSize: 25, // Only cache the last 25 pages \\tcacheTime: 60 * 30 // 30 minutes in seconds }); // Disable caching entirely let snorkel = new ReefSnorkel({ cache: false });  Options \\u0026amp; Settings In addition to your routes, Reef Router accepts a few options you can use to customize how the router behaves.\\nlet snorkel = new ReefSnorkel({ loading: \\u0026#39;reef-loading\\u0026#39;, // A class that\\u0026#39;s added to the HTML element while new content is loading \\troot: \\u0026#39;/\\u0026#39;, // The root domain for the app });  API Reference Reef, Snorkel, and Reef Router expose a set of options, methods, and custom events that you can hook into.\\nGlobal Methods Reef.debug() Turn debug mode on or off. Pass in true to turn debug mode on, and false to turn it off.\\n// Turn debug mode on Reef.debug(true); // Turn debug mode off Reef.debug(false);  Reef.clone() Create an immutable copy of an array, object, Map(), or Set().\\nReef.clone({});  Reef.trueTypeOf() Get the true type of an object.\\nReef.trueTypeOf([]); // \\u0026#34;array\\u0026#34; Reef.trueTypeOf({}); // \\u0026#34;object\\u0026#34; Reef.trueTypeOf(\\u0026#39;\\u0026#39;); // \\u0026#34;string\\u0026#34; Reef.trueTypeOf(1); // \\u0026#34;number\\u0026#34;  Reef.err() Log a warning in the console conditionally only if debug mode is on.\\nReef.debug(\\u0026#39;You did something, silly!\\u0026#39;);  Reef.emit() Emit a custom event. Pass in the element to emit the event on, the event name, and optionally, event details as arguments.\\n// Emits the \\u0026#34;awesome\\u0026#34; event on the document Reef.emit(document, \\u0026#39;awesome\\u0026#39;); // Emit the \\u0026#34;awesome\\u0026#34; event on the #app element, with some details let app = document.querySelector(\\u0026#39;#app\\u0026#39;); Reef.emit(app, \\u0026#39;awesome\\u0026#39;, { whoIs: \\u0026#39;You are\\u0026#39; });  You can listen for custom events with the Element.addEventListener() method.\\nInstance Methods Reef.prototype.render() Render a Reef component in the UI.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); app.render();  Reef.prototype.attach() Attach one or more components to a Reef component. Pass in the component or an array of components as an argument.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;ul id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/ul\\u0026gt;\\u0026#39; }); let todos = new Reef(\\u0026#39;#todos\\u0026#39;, { template: \\u0026#39;\\u0026lt;li\\u0026gt;Build something with Reef\\u0026lt;/li\\u0026gt;\\u0026#39; }); // Attach one item app.attach(todos); // Attach an array of items app.attach([todos]);  Reef.prototype.detach() Detach an attached component. Pass in the component or an array of components as an argument.\\n// Detach one component app.detach(todos); // Detach an array of components app.detach([todos]);  Reef.prototype.do() Run a setter function. Pass in the name of the setter, and a comma-separate list of any arguments.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { count: 0 }, template: function (props) { return count; }, setters: { increase: function (props) { props.count++; } } }); // Run the increase setter app.do(\\u0026#39;increase\\u0026#39;);  Reef.prototype.get() Run a getter function. Pass in the name of the getter, and a comma-separate list of any arguments.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { count: 0 }, template: function (props) { return count; }, getters: { count: function (props) { return props.count; } } }); // Run the count getter app.get(\\u0026#39;count\\u0026#39;);  ReefSnorkel.prototype.run() Start or restart a Snorkel instance. This is run automatically when instantiating a new Snorkel instance.\\n// A snorkel instance let snorkel1 = new ReefSnorkel(); // Another instance // This stops snorkel1 from running let snorkel2 = new ReefSnorkel({ autoLinks: false }); // This restarts snorkel1, and stops snorkel2 snorkel1.run();  ReefSnorkel.prototype.stop() Stops a snorkel instance from running.\\nlet snorkel = new ReefSnorkel(); snorkel.stop();  ReefSnorkel.prototype.visit() Visit a URL. Pass the URL in as an argument.\\nlet snorkel = new ReefSnorkel(); snorkel.visit(\\u0026#39;/about\\u0026#39;);  ReefSnorkel.prototype.clearCache() Clear the cache for a snorkel instance.\\nlet snorkel = new ReefSnorkel(); snorkel.clearCache();  ReefSnorkel.prototype.addComponent() Add one or more Reef components to be automatically rendered whenever the route changes. Pass in the component or an array of components as an argument.\\n// A Reef component let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); // Snorkel let snorkel = new ReefSnorkel(); // Add one component snorkel.addComponent(app); // Add an array of components snorkel.addComponent([app]);  ReefSnorkel.prototype.removeComponent() Remove one or more Reef components from being automatically rendered whenever the route changes. Pass in the component or an array of components as an argument.\\n// A Reef component let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); // Snorkel let snorkel = new ReefSnorkel(); // Remove one component snorkel.removeComponent(app); // Remove an array of components snorkel.removeComponent([app]);  ReefRouter.prototype.addRoutes() Add one or more routes to a Reef Router instance. Pass in a route or array of routes as an argument.\\nlet router = new ReefRouter(); // Add one route router.addRoutes({ url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }); // Add an array of routes router.addRoutes([ { url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }, { url: \\u0026#39;/contact\\u0026#39;, title: \\u0026#39;Contact Us\\u0026#39; } ]);  ReefRouter.prototype.removeRoutes() Remove one or more routes from a Reef Router instance. Pass in a route or array of routes as an argument.\\nlet router = new ReefRouter({ routes: [ { url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }, { url: \\u0026#39;/contact\\u0026#39;, title: \\u0026#39;Contact Us\\u0026#39; } ] }); // Remove one route router.removeRoutes({ url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }); // Remove an array of routes router.removeRoutes([ { url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }, { url: \\u0026#39;/contact\\u0026#39;, title: \\u0026#39;Contact Us\\u0026#39; } ]);  ReefRouter.prototype.addComponent() Add one or more Reef components to be automatically rendered whenever the route changes. Pass in the component or an array of components as an argument.\\n// A Reef component let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); // Reef Router let router = new ReefRouter(); // Add one component router.addComponent(app); // Add an array of components router.addComponent([app]);  ReefRouter.prototype.removeComponent() Remove one or more Reef components from being automatically rendered whenever the route changes. Pass in the component or an array of components as an argument.\\n// A Reef component let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); // Reef Router let router = new ReefRouter(); // Add one component router.removeComponent(app); // Add an array of components router.removeComponent([app]);  ReefRouter.prototype.visit() Visit a URL. Pass the URL in as an argument.\\nlet router = new ReefRouter(); router.visit(\\u0026#39;/about\\u0026#39;);  ReefRouter.prototype.navigate() (deprecated) This method has been replaced with ReefRouter.prototype.visit(). It still works, but will be removed in the next major version release.\\nInstance Properties Reef.prototype.data Get a reactive copy of the app data.\\nlet data = app.data;  Reef.prototype.elem The element the component is associated with. Returns a string or Node.\\nlet elem = app.elem;  Reef.prototype.allowHTML Whether or not HTML is allowed in the Reef component data. Returns a boolean.\\nlet allowed = app.allowHTML;  ReefRouter.prototype.routes An immutable array of the routes for a router instance.\\nlet routes = router.routes;  ReefRouter.prototype.current The current route for a router.\\nlet current = router.current;  Events Reef, Snorkel, and Reef Router emit custom events throughout the life cycle of a component or instance.\\nAll Reef events follow a library:event pattern. Unless otherwise specified, all events are emitted on the document element. Event details can be accessed on the event.details property.\\n// Listen for when Reef components are rendered into the DOM document.addEventListener(\\u0026#39;reef:render\\u0026#39;, function (event) { console.log(event.target); // The element it was rendered into \\tconsole.log(event.detail); // The data used for the render });  Reef Events  reef:ready is emitted when Reef is loaded into the DOM and ready to use. reef:initialized is emitted when a new Reef component is initialized.  event.detail - the instance  reef:before-render is emitted on an element before a new UI is rendered into it.  event.target - the element the component is being rendered into event.detail - the current component data event.preventDefault() - stop the component from rendering  reef:render is emitted on an element after a new UI is rendered into it.  event.target - the element the component was rendered into event.detail - the component data at time of render  reef:attached is emitted when one or more components is attached to a component.  event.detail - an object with the component and an array of attached components  reef:detached is emitted when one or more components is detached from a component.  event.detail - an object with the component and an array of detached components   Snorkel Events  snorkel:ready is emitted when Snorkel is loaded into the DOM and ready to use. snorkel:initialized is emitted when a new Snorkel instance is initialized.  event.detail - the instance  snorkel:stopped is emitted when a Snorkel instance is stopped.  event.detail - the instance  snorkel:before is emitted before a new route is fetched.  event.detail - an object with the current and next URLs event.preventDefault() - stop the route from being fetched  snorkel:after is emitted after a new route is fetched and loaded into the UI  event.detail - an object with the current and previous URLs  snorkel:not-found is emitted when a fetched route is not found  event.detail - an object with the current and notFound URLs  snorkel:components-added is emitted when one or more components are added for rendering on route changes.  event.detail - an object with the snorkel instance and an array of added components  snorkel:components-removed is emitted when one or more components are removed from rendering on route changes.  event.detail - an object with the snorkel instance and an array of removed components  snorkel:cache-updated is emitted when a URL is added to the internal cache.  event.detail - an object with the url and html string  snorkel:cache-cleared is emitted when the internal cache is cleared.  event.detail - the Snorkel instance   Router Events  router:ready is emitted when Reef Router is loaded into the DOM and ready to use. router:initialized is emitted when a new Router instance is initialized.  event.detail - the instance  router:before is emitted before a new route is fetched.  event.detail - an object with the current and next URLs event.preventDefault() - stop the route from being fetched  router:after is emitted after a new route is fetched and loaded into the UI  event.detail - an object with the current and previous URLs  router:routes-added is emitted when one or more routes are added to the router.  event.detail - an object with the router instance and an array of added routes  router:routes-removed is emitted when one or more routes are removed from the router.  event.detail - an object with the router instance and an array of removed routes  router:components-added is emitted when one or more components are added for rendering on route changes.  event.detail - an object with the router instance and an array of added components  router:components-removed is emitted when one or more components are removed from rendering on route changes.  event.detail - an object with the router instance and an array of removed components   Deprecated Events These are events that are still emitted, but will be removed in the next major version release. You should migrate to one of the events listed above whenever possible.\\n render was replaced by reef:render beforeRouteUpdated was replaced by router:before routeUpdated was replaced by router:after  Options All of the options for Reef, Snorkel, and Reef Router. This section is still a work-in-progress.\\nReef Options // This can be a string or a element let elem = \\u0026#39;#app\\u0026#39;; new Reef(elem, { // The component data \\tdata: {}, // A component or array of components to attach to \\tattachTo: [], // A data store to use \\t// If used, the data option is ignored \\tstore: null, // A router to use for this component \\trouter: null, // An object of setter methods \\tsetters: {}, // An object of getter methods \\tgetters: {} });  Snorkel Options new ReefSnorke({ // If true, automatically run Snorkel on all links \\tautoLinks: true, // The selector for links to follow \\t// Only needed if autoLinks is false or if you\\u0026#39;ve used an ignore selector \\tfollow: \\u0026#39;[snorkel]\\u0026#39;, // The selector for links to ignore \\tignore: \\u0026#39;[snorkel-ignore]\\u0026#39;, // The selector for links that should replace the current state \\t// (instead of adding a new entry to browser history) \\treplace: \\u0026#39;[snorkel=\\u0026#34;replace\\u0026#34;]\\u0026#39;, // The class that\\u0026#39;s added to the HTML element while a new route is loading \\tloading: \\u0026#39;reef-loading\\u0026#39;, // The root for your app \\t// If your app is on a sub-page, you may want to change this \\troot: \\u0026#39;/\\u0026#39;, // If true, cache views for use with the forward/back button \\tcache: true, // How many items to store in cache \\tcacheSize: 50, // How long to keep cached items for, in seconds \\tcacheTime: 3600, });  Reef Router Options new ReefRouter({ // An array of routes \\troutes: [], // The root path for your app \\troot: \\u0026#39;\\u0026#39;, // The format to use for the document.title \\t// Can be a string, or a function that returns a string \\t// Accepts the route object and page title as arguments \\ttitle: function (route, title) { return title; }, // If true, use a hashbang pattern instead of real URLs \\tuseHash: false });  API Reference Reef, Snorkel, and Reef Router expose a set of options, methods, and custom events that you can hook into.\\nGlobal Methods Reef.debug() Turn debug mode on or off. Pass in true to turn debug mode on, and false to turn it off.\\n// Turn debug mode on Reef.debug(true); // Turn debug mode off Reef.debug(false);  Reef.clone() Create an immutable copy of an array, object, Map(), or Set().\\nReef.clone({});  Reef.err() Log a warning in the console conditionally only if debug mode is on.\\nReef.err(\\u0026#39;You did something, silly!\\u0026#39;);  Reef.emit() Emit a custom event. Pass in the element to emit the event on, the event name, and optionally, event details as arguments.\\n// Emits the \\u0026#34;awesome\\u0026#34; event on the document Reef.emit(document, \\u0026#39;awesome\\u0026#39;); // Emit the \\u0026#34;awesome\\u0026#34; event on the #app element, with some details let app = document.querySelector(\\u0026#39;#app\\u0026#39;); Reef.emit(app, \\u0026#39;awesome\\u0026#39;, { whoIs: \\u0026#39;You are\\u0026#39; });  You can listen for custom events with the Element.addEventListener() method.\\nComponent Methods Reef.prototype.render() Render a Reef component in the UI.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); app.render();  Reef.prototype.attach() Attach one or more components to a Reef component. Pass in the component or an array of components as an argument.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;ul id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/ul\\u0026gt;\\u0026#39; }); let todos = new Reef(\\u0026#39;#todos\\u0026#39;, { template: \\u0026#39;\\u0026lt;li\\u0026gt;Build something with Reef\\u0026lt;/li\\u0026gt;\\u0026#39; }); // Attach one item app.attach(todos); // Attach an array of items app.attach([todos]);  Reef.prototype.detach() Detach an attached component. Pass in the component or an array of components as an argument.\\n// Detach one component app.detach(todos); // Detach an array of components app.detach([todos]);  Reef.prototype.do() Run a setter function. Pass in the name of the setter, and a comma-separate list of any arguments.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { count: 0 }, template: function (props) { return count; }, setters: { increase: function (props) { props.count++; } } }); // Run the increase setter app.do(\\u0026#39;increase\\u0026#39;);  Reef.prototype.get() Run a getter function. Pass in the name of the getter, and a comma-separate list of any arguments.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { count: 0 }, template: function (props) { return count; }, getters: { count: function (props) { return props.count; } } }); // Run the count getter app.get(\\u0026#39;count\\u0026#39;);  ReefSnorkel.prototype.run() Start or restart a Snorkel instance. This is run automatically when instantiating a new Snorkel instance.\\n// A snorkel instance let snorkel1 = new ReefSnorkel(); // Another instance // This stops snorkel1 from running let snorkel2 = new ReefSnorkel({ autoLinks: false }); // This restarts snorkel1, and stops snorkel2 snorkel1.run();  ReefSnorkel.prototype.stop() Stops a snorkel instance from running.\\nlet snorkel = new ReefSnorkel(); snorkel.stop();  ReefSnorkel.prototype.visit() Visit a URL. Pass the URL in as an argument.\\nlet snorkel = new ReefSnorkel(); snorkel.visit(\\u0026#39;/about\\u0026#39;);  ReefSnorkel.prototype.clearCache() Clear the cache for a snorkel instance.\\nlet snorkel = new ReefSnorkel(); snorkel.clearCache();  ReefSnorkel.prototype.addComponent() Add one or more Reef components to be automatically rendered whenever the route changes. Pass in the component or an array of components as an argument.\\n// A Reef component let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); // Snorkel let snorkel = new ReefSnorkel(); // Add one component snorkel.addComponent(app); // Add an array of components snorkel.addComponent([app]);  ReefSnorkel.prototype.removeComponent() Remove one or more Reef components from being automatically rendered whenever the route changes. Pass in the component or an array of components as an argument.\\n// A Reef component let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); // Snorkel let snorkel = new ReefSnorkel(); // Remove one component snorkel.removeComponent(app); // Remove an array of components snorkel.removeComponent([app]);  ReefRouter.prototype.addRoutes() Add one or more routes to a Reef Router instance. Pass in a route or array of routes as an argument.\\nlet router = new ReefRouter(); // Add one route router.addRoutes({ url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }); // Add an array of routes router.addRoutes([ { url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }, { url: \\u0026#39;/contact\\u0026#39;, title: \\u0026#39;Contact Us\\u0026#39; } ]);  ReefRouter.prototype.removeRoutes() Remove one or more routes from a Reef Router instance. Pass in a route or array of routes as an argument.\\nlet router = new ReefRouter({ routes: [ { url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }, { url: \\u0026#39;/contact\\u0026#39;, title: \\u0026#39;Contact Us\\u0026#39; } ] }); // Remove one route router.removeRoutes({ url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }); // Remove an array of routes router.removeRoutes([ { url: \\u0026#39;/about\\u0026#39;, title: \\u0026#39;About\\u0026#39; }, { url: \\u0026#39;/contact\\u0026#39;, title: \\u0026#39;Contact Us\\u0026#39; } ]);  ReefRouter.prototype.addComponent() Add one or more Reef components to be automatically rendered whenever the route changes. Pass in the component or an array of components as an argument.\\n// A Reef component let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); // Reef Router let router = new ReefRouter(); // Add one component router.addComponent(app); // Add an array of components router.addComponent([app]);  ReefRouter.prototype.removeComponent() Remove one or more Reef components from being automatically rendered whenever the route changes. Pass in the component or an array of components as an argument.\\n// A Reef component let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); // Reef Router let router = new ReefRouter(); // Add one component router.removeComponent(app); // Add an array of components router.removeComponent([app]);  ReefRouter.prototype.visit() Visit a URL. Pass the URL in as an argument.\\nlet router = new ReefRouter(); router.visit(\\u0026#39;/about\\u0026#39;);  ReefRouter.prototype.navigate() (deprecated) This method has been replaced with ReefRouter.prototype.visit(). It still works, but will be removed in the next major version release.\\nInstance Properties Reef.prototype.data Get a reactive copy of the app data.\\nlet data = app.data;  Reef.prototype.elem The element the component is associated with. Returns a string or Node.\\nlet elem = app.elem;  Reef.prototype.allowHTML Whether or not HTML is allowed in the Reef component data. Returns a boolean.\\nlet allowed = app.allowHTML;  ReefRouter.prototype.routes An immutable array of the routes for a router instance.\\nlet routes = router.routes;  ReefRouter.prototype.current The current route for a router.\\nlet current = router.current;  Events Reef, Snorkel, and Reef Router emit custom events throughout the life cycle of a component or instance.\\nAll Reef events follow a library:event pattern. Unless otherwise specified, all events are emitted on the document element. Event details can be accessed on the event.details property.\\n// Listen for when Reef components are rendered into the DOM document.addEventListener(\\u0026#39;reef:render\\u0026#39;, function (event) { console.log(event.target); // The element it was rendered into \\tconsole.log(event.detail); // The data used for the render });  Reef Events  reef:ready is emitted when Reef is loaded into the DOM and ready to use. reef:initialized is emitted when a new Reef component is initialized.  event.detail - the instance  reef:before-render is emitted on an element before a new UI is rendered into it.  event.target - the element the component is being rendered into event.detail - the current component data event.preventDefault() - stop the component from rendering  reef:render is emitted on an element after a new UI is rendered into it.  event.target - the element the component was rendered into event.detail - the component data at time of render  reef:attached is emitted when one or more components is attached to a component.  event.detail - an object with the component and an array of attached components  reef:detached is emitted when one or more components is detached from a component.  event.detail - an object with the component and an array of detached components   Snorkel Events  snorkel:ready is emitted when Snorkel is loaded into the DOM and ready to use. snorkel:initialized is emitted when a new Snorkel instance is initialized.  event.detail - the instance  snorkel:stopped is emitted when a Snorkel instance is stopped.  event.detail - the instance  snorkel:before is emitted before a new route is fetched.  event.detail - an object with the current and next URLs event.preventDefault() - stop the route from being fetched  snorkel:after is emitted after a new route is fetched and loaded into the UI  event.detail - an object with the current and previous URLs  snorkel:not-found is emitted when a fetched route is not found  event.detail - an object with the current and notFound URLs  snorkel:components-added is emitted when one or more components are added for rendering on route changes.  event.detail - an object with the snorkel instance and an array of added components  snorkel:components-removed is emitted when one or more components are removed from rendering on route changes.  event.detail - an object with the snorkel instance and an array of removed components  snorkel:cache-updated is emitted when a URL is added to the internal cache.  event.detail - an object with the url and html string  snorkel:cache-cleared is emitted when the internal cache is cleared.  event.detail - the Snorkel instance   Router Events  router:ready is emitted when Reef Router is loaded into the DOM and ready to use. router:initialized is emitted when a new Router instance is initialized.  event.detail - the instance  router:before is emitted before a new route is fetched.  event.detail - an object with the current and next URLs event.preventDefault() - stop the route from being fetched  router:after is emitted after a new route is fetched and loaded into the UI  event.detail - an object with the current and previous URLs  router:routes-added is emitted when one or more routes are added to the router.  event.detail - an object with the router instance and an array of added routes  router:routes-removed is emitted when one or more routes are removed from the router.  event.detail - an object with the router instance and an array of removed routes  router:components-added is emitted when one or more components are added for rendering on route changes.  event.detail - an object with the router instance and an array of added components  router:components-removed is emitted when one or more components are removed from rendering on route changes.  event.detail - an object with the router instance and an array of removed components   Deprecated Events These are events that are still emitted, but will be removed in the next major version release. You should migrate to one of the events listed above whenever possible.\\n render was replaced by reef:render beforeRouteUpdated was replaced by router:before routeUpdated was replaced by router:after  Options All of the options for Reef, Snorkel, and Reef Router. This section is still a work-in-progress.\\nReef Options // This can be a string or a element let elem = \\u0026#39;#app\\u0026#39;; new Reef(elem, { // The component data \\tdata: {}, // A component or array of components to attach to \\tattachTo: [], // A data store to use \\t// If used, the data option is ignored \\tstore: null, // A router to use for this component \\trouter: null, // An object of setter methods \\tsetters: {}, // An object of getter methods \\tgetters: {} });  Snorkel Options new ReefSnorke({ // If true, automatically run Snorkel on all links \\tautoLinks: true, // The selector for links to follow \\t// Only needed if autoLinks is false or if you\\u0026#39;ve used an ignore selector \\tfollow: \\u0026#39;[snorkel]\\u0026#39;, // The selector for links to ignore \\tignore: \\u0026#39;[snorkel-ignore]\\u0026#39;, // The selector for links that should replace the current state \\t// (instead of adding a new entry to browser history) \\treplace: \\u0026#39;[snorkel=\\u0026#34;replace\\u0026#34;]\\u0026#39;, // The class that\\u0026#39;s added to the HTML element while a new route is loading \\tloading: \\u0026#39;reef-loading\\u0026#39;, // The root for your app \\t// If your app is on a sub-page, you may want to change this \\troot: \\u0026#39;/\\u0026#39;, // If true, cache views for use with the forward/back button \\tcache: true, // How many items to store in cache \\tcacheSize: 50, // How long to keep cached items for, in seconds \\tcacheTime: 3600, });  Reef Router Options new ReefRouter({ // An array of routes \\troutes: [], // The root path for your app \\troot: \\u0026#39;\\u0026#39;, // The format to use for the document.title \\t// Can be a string, or a function that returns a string \\t// Accepts the route object and page title as arguments \\ttitle: function (route, title) { return title; }, // If true, use a hashbang pattern instead of real URLs \\tuseHash: false });  Browser Compatibility Reef works in all modern browsers. That means:\\n The latest versions of Edge, Chrome, Firefox, and Safari. Mobile Safari, Chrome, and Firefox on Safari. WebView, Chrome, and Firefox for Android.  If you need to support older browsers, you\\u0026rsquo;ll need to transpile your code into ES5 with BabelJS.\\nLicense The code is available under the MIT License.\\n\",\"title\":\"Reef v8\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v8/\"},{\"content\":\" A lightweight library for creating reactive, state-based components and UI. Reef is a simpler alternative to React, Vue, and other large frameworks.\\n Features  Weighs just 2.9kb minified and gzipped, with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a \\u0026lt;script\\u0026gt; element or ES module import\\u0026mdash;no command line or transpiling required (though you can if you want). Uses DOM diffing to update only the things that have changed. Has Redux/Vuex-like data stores, with setters and getters baked right in. Automatically encodes and sanitizes data to help protect you from cross-site scripting (XSS) attacks. Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Compatible with all modern browsers.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef only updates things that have changed instead of clobbering the DOM and removing focus from your form fields. It also automatically renders a new UI when your data updates, and helps protect you from XSS attacks.\\nIf you\\u0026rsquo;re craving a simpler, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGetting Started 1. Include Reef on your site Reef works without any build step.\\nThe CDN is the fastest and simplest way to get started, but you can use importable modules or a direct download if you\\u0026rsquo;d prefer.\\n\\u0026lt;!-- Get the latest major version --\\u0026gt; \\u0026lt;script src=\\u0026#34;https://cdn.jsdelivr.net/npm/reefjs@9/dist/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; Reef uses semantic versioning. You can grab a major, minor, or patch version from the CDN with the @1.2.3 syntax. You can find all available versions under releases.\\n More ways to install Reef ES Modules\\nReef also supports modern browsers and module bundlers (like Rollup, Webpack, Snowpack, and so on) using the ES modules import syntax. Use the .es version.\\nimport Reef from \\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@9/dist/reef.es.min.js\\u0026#39;;  NPM\\nYou can also use NPM (or your favorite package manager). First, install with NPM.\\nnpm install reefjs --save Then import the package.\\nimport Reef from \\u0026#39;reefjs\\u0026#39;;  CommonJS\\nIf you use NodeJS, you can import Reef using the require() method with the .cjs version.\\nlet Reef = require(\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@9/dist/reef.cjs.min.js\\u0026#39;);  AMD\\nIf you use RequireJS, SystemJS, and other AMD formats, you can import Reef with the .amd version.\\nrequirejs([\\u0026#39;https://cdn.jsdelivr.net/npm/reefjs@9/dist/reef.amd.min.js\\u0026#39;], function (Reef) { //... });  Direct Download\\nYou can download the files directly from GitHub.\\nCompiled and production-ready code can be found in the dist directory. The src directory contains development code.\\n\\u0026lt;script src=\\u0026#34;path/to/reef.min.js\\u0026#34;\\u0026gt;\\u0026lt;/script\\u0026gt; \\n2. Add an element to render your component/UI into This is typically an empty div with a targetable selector.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt; 3. Create your component Create a new Reef() instance, passing in two arguments: your selector, and your options.\\nProvide a selector The first argument is the selector for the element you want to render the UI into. Alternatively, you can pass in the element itself.\\n// This works let app = new Reef(\\u0026#39;#app\\u0026#39;); // This does too let elem = document.querySelector(\\u0026#39;#app\\u0026#39;); let app = new Reef(elem);  Provide a Template The second argument is an object of options. It requires a template property, as either a string or a function that returns a string, to render into the DOM.\\n// Your template can be a string let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39; }); // It can also be a function that returns a string let app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return \\u0026#39;\\u0026lt;h1\\u0026gt;Hello, world!\\u0026lt;/h1\\u0026gt;\\u0026#39;; } });  [Optional] Add State/Data As an optional property of the options argument, you can include state for your component with the data property.\\nThe data object is automatically encoded and passed into your template function, so that you can use it to customize your template.\\n// Some data let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Template literals give you a simple, JSX-like templating experience.\\n4. Render your component Render your component by calling the render() method on it.\\napp.render();  Try the demo on CodePen \\u0026rarr;\\nState Management Reef uses data reactivity to update your UI.\\nData reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\n// Create a component and render it let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } }); app.render(); // This causes component to update with \\u0026#34;Hi, universe\\u0026#34; app.data.greeting = \\u0026#39;Hi\\u0026#39;; app.data.name = \\u0026#39;Universe\\u0026#39;;  You can also update the entire data object.\\n// This will also update the UI app.data = { greeting: \\u0026#39;Hi\\u0026#39;, name: \\u0026#39;Universe\\u0026#39; };  Try data reactivity on CodePen \\u0026rarr;\\nFor better performance, multiple property updates may be batched into a single, asynchronous render. You can detect when a render has been completed using the reef:render event hook.\\nNon-Reactive Data Sometimes, you want to update data without updating the UI.\\nYou can get an immutable copy of your data by passing it into the Reef.clone() method. This creates a non-reactive copy of your data that won\\u0026rsquo;t affect the state of your component or cause a UI update.\\n// Create an immutable copy of the app.data let data = Reef.clone(app.data); // Update the copy // This does NOT update the app.data or render a new UI data.name = \\u0026#39;Universe\\u0026#39;;  When you\\u0026rsquo;re ready to update your component data, you can set the component\\u0026rsquo;s data property to your cloned copy.\\n// Reactively update the component data app.data = data;  Try non-reactive data on CodePen \\u0026rarr;\\nNote: You can use the Reef.clone() method to create an immutable copy of any array or object, not just your component data.\\nAdvanced Components As your project gets bigger, the way you manage components and data may need to grow with it. Reef has some options to help make things a little easier.\\nHTML Templates Default and state-based HTML attributes You can use component data to conditionally include or change the value of HTML attributes in your template.\\nUse the reef-checked, reef-selected, and reef-value attributes to dynamically control the checked, selected, and value attributes, respectively. Use a falsy value when the item should not be checked or selected.\\nIn the example below, the checkbox is checked when agreeToTOS is true.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { agreeToTOS: true }, template: function (props) { return ` \\u0026lt;label\\u0026gt; \\u0026lt;input type=\\u0026#34;checkbox\\u0026#34; reef-checked=\\u0026#34;${agreeToTOS}\\u0026#34;\\u0026gt; \\u0026lt;/label\\u0026gt;`; } });  You might also want to use a default value when an element initially renders, but defer to any changes the user makes after that.\\nYou can do that with the reef-default-checked, reef-default-selected, and reef-default-value attributes.\\nIn this example, Hermione has the [selected] attribute on it when first rendered, but will defer to whatever changes the user makes when diffing and updating the UI.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: function () { return ` \\u0026lt;label for=\\u0026#34;wizards\\u0026#34;\\u0026gt;Who is the best wizard?\\u0026lt;/label\\u0026gt; \\u0026lt;select\\u0026gt; \\u0026lt;option\\u0026gt;Harry\\u0026lt;/option\\u0026gt; \\u0026lt;option reef-default-selected\\u0026gt;Hermione\\u0026lt;/option\\u0026gt; \\u0026lt;option\\u0026gt;Neville\\u0026lt;/option\\u0026gt; \\u0026lt;/select\\u0026gt;`; } });  Try controlling form attributes on CodePen \\u0026rarr;\\nPreventing Cross-Site Scripting (XSS) Attacks To reduce your risk of cross-site scripting (XSS) attacks, Reef automatically encodes any markup in your data before passing it into your template.\\nYou can disable this feature by setting the allowHTML option to true.\\nImportant! Do NOT do this with third-party or user-provided data. This exposes you to the risk of cross-site scripting (XSS) attacks.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;\\u0026lt;strong\\u0026gt;Hello\\u0026lt;/strong\\u0026gt;\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; }, allowHTML: true // Do NOT use with third-party/user-supplied data });  Try allowing HTML in your data on CodePen \\u0026rarr;\\nGetting the element the template is being rendered into An optional second argument is passed into the template() function: the element the template is being rendered into.\\nThis is particularly handy if you have data attributes on your element that affect what\\u0026rsquo;s rendered into the template.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34; data-greeting=\\u0026#34;Hello\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { name: \\u0026#39;world\\u0026#39; }, template: function (props, elem) { return `\\u0026lt;h1\\u0026gt;${elem.getAttribute(\\u0026#39;data-greeting\\u0026#39;)}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } });  Try getting the HTML element that the template was rendered into on CodePen \\u0026rarr;\\nNested Components If you\\u0026rsquo;re managing a bigger app, you may have components nested inside other components.\\nReef provides you with a way to attach nested components to their parent components. When the parent component is updated, it will automatically update the UI of its nested components if needed.\\nAssociate a nested component with its parent using the attachTo key in your options object. You can provide a component or array of components for a value.\\nYou only need to render the parent component. It\\u0026rsquo;s nested components will render automatically.\\n// Parent component let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello, world!\\u0026#39; }, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.greeting}\\u0026lt;/h1\\u0026gt; \\u0026lt;div id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/div\\u0026gt;`; } }); // Nested component let todos = new Reef(\\u0026#39;#todos\\u0026#39;, { data: { todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, template: function (props) { return ` \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; }, attachTo: app }); app.render();  Try nested components on CodePen \\u0026rarr;\\nAttaching and Detaching Nested Components You can attach or detach nested components at any time using the attach() and detach() methods on the parent component.\\nProvide an individual component or array of components as an argument.\\n// Attach components app.attach(todos); app.attach([todos]); // Detach components app.detach(todos); app.detach([todos]);  Try attaching nested components on CodePen \\u0026rarr;\\nShared State with Data Stores A Data Store is a special Reef object that holds reactive data you can share with multiple components.\\nAny time you update the data in your Data Store, any components that use the data will also be updated, and will render again if there are any UI changes.\\nCreate a Data Store using the new Reef.Store() constructor.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] } });  To use your Data Store with a component, pass it in with the store property instead of providing a data object.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { store: store, template: function (props) { return ` \\u0026lt;h1\\u0026gt;${props.heading}\\u0026lt;/h1\\u0026gt; \\u0026lt;ul\\u0026gt; ${props.todos.map(function (todo) { return `\\u0026lt;li\\u0026gt;${todo}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } });  When using a Data Store, a component will have no data of its own. All state/data updates must happen by updating the store.\\n// Add a todo item store.data.todos.push(\\u0026#39;Take a nap... zzzz\\u0026#39;);  Try creating a Data Store on CodePen \\u0026rarr;\\nSetters \\u0026amp; Getters Reef\\u0026rsquo;s reactive data makes updating your UI as simple updating an object property.\\nBut as your app scales, you may find that keeping track of what\\u0026rsquo;s updating state and causing changes to the UI becomes harder to track and maintain.\\nSetters and getters provide you with a way to control how data flows in and out of your component.\\nSetters Setters are functions that update your component or store data.\\nCreate setters by passing in an object of setter functions with the setters property in your options object. The first parameter on a setter function is the store or component data. You can add as many other parameters as you\\u0026rsquo;d like.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, setters: { // Add a new todo item to the component \\taddTodo: function (props, todo) { props.todos.push(todo); } } });  Use setter functions by calling the do() method on your component or store. Pass in the name of the setter, along with any required arguments (except for props).\\n// Add a new todo item store.do(\\u0026#39;addTodo\\u0026#39;, \\u0026#39;Take a nap... zzzz\\u0026#39;);  When a component or store has setter functions, they become the only way to update app or store data.\\nThis protects your component or store data from unwanted changes. The data property always returns an immutable copy.\\n// This will NOT update the store.data or the UI store.data.todos.push(\\u0026#39;Take a nap... zzzz\\u0026#39;);  Try working with setter functions on CodePen \\u0026rarr;\\nGetters Getters are functions that parse data from your component or store and return a value.\\nThey\\u0026rsquo;re useful if you need to manipulate and retrieve the same data across multiple views of components. Rather than having to import helper functions, you can attach them directly to the component or store.\\nCreate getters by passing in an object of getter functions with the getters property in your options object. The first parameter on a getter function is the store or component data. You can add as many other parameters as you\\u0026rsquo;d like.\\nSupport for parameters besides props requires version 8.2.0 or higher.\\nlet store = new Reef.Store({ data: { heading: \\u0026#39;My Todos\\u0026#39;, todos: [\\u0026#39;Swim\\u0026#39;, \\u0026#39;Climb\\u0026#39;, \\u0026#39;Jump\\u0026#39;, \\u0026#39;Play\\u0026#39;] }, getters: { total: function (props) { return props.todos.length; } } });  Use getter functions by calling the get() method on your component or store. Pass in the name of getter, along with any required arguments (except for props).\\n// Get the number of todo items store.get(\\u0026#39;total\\u0026#39;);  Try working with getter functions on CodePen \\u0026rarr;\\nAsynchronous Data You can use asynchronous data (such as content from an API) in your templates.\\nSet an initial default value, make your API call, and update the data property once you get data back. This will automatically trigger a render.\\n// Create an app let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { articles: [] }, template: function (props) { // If there are no articles  if (!props.articles.length) { return `\\u0026lt;p\\u0026gt;There are no articles.\\u0026lt;/p\\u0026gt;`; } // Otherwise, show the articles \\treturn ` \\u0026lt;ul\\u0026gt; ${props.articles.map(function (article) { return `\\u0026lt;li\\u0026gt; \\u0026lt;strong\\u0026gt;\\u0026lt;a href=\\u0026#34;#\\u0026#34;\\u0026gt;${article.title}.\\u0026lt;/a\\u0026gt;\\u0026lt;/strong\\u0026gt; ${article.body}\\u0026lt;/li\\u0026gt;`; }).join(\\u0026#39;\\u0026#39;)} \\u0026lt;/ul\\u0026gt;`; } }); // Fetch API data // Then, update the app data fetch(\\u0026#39;https://jsonplaceholder.typicode.com/posts\\u0026#39;).then(function (response) { return response.json(); }).then(function (data) { app.data.articles = data; });  Try create a template from asynchronous data on CodePen \\u0026rarr;\\nYou might also choose to hard-code a loading message in your markup.\\n\\u0026lt;div id=\\u0026#34;app\\u0026#34;\\u0026gt;Loading...\\u0026lt;/div\\u0026gt; Debugging By default, Reef fails silently. You can put Reef into debug mode to expose helpful error message in the Console tab of your browser\\u0026rsquo;s Developer Tools.\\nTurn debug mode on or off with the Reef.debug() method. Pass in true to turn it on, and false to turn it off.\\n// Turns debug mode on Reef.debug(true); // Turns debug mode off Reef.debug(false);  API Reference Reef exposes a set of options, methods, and custom events that you can hook into.\\nGlobal Methods Run these methods directly on the Reef object.\\nReef.debug() Turn debug mode on or off. Pass in true to turn debug mode on, and false to turn it off.\\n// Turn debug mode on Reef.debug(true); // Turn debug mode off Reef.debug(false);  Reef.clone() Create an immutable copy of an array, object, Map(), or Set().\\nReef.clone({});  Reef.err() Log a warning in the console conditionally only if debug mode is on.\\nReef.err(\\u0026#39;You did something, silly!\\u0026#39;);  Reef.emit() Emit a custom event. Pass in the element to emit the event on, the event name, and optionally, event details as arguments.\\n// Emits the \\u0026#34;awesome\\u0026#34; event on the document Reef.emit(document, \\u0026#39;awesome\\u0026#39;); // Emit the \\u0026#34;awesome\\u0026#34; event on the #app element, with some details let app = document.querySelector(\\u0026#39;#app\\u0026#39;); Reef.emit(app, \\u0026#39;awesome\\u0026#39;, { whoIs: \\u0026#39;You are\\u0026#39; });  You can listen for custom events with the Element.addEventListener() method.\\nComponent Methods Run these methods on individual Reef components.\\nReef.prototype.render() Render a Reef component in the UI.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;Hello world!\\u0026#39; }); app.render();  Reef.prototype.attach() Attach one or more components to a Reef component. Pass in the component or an array of components as an argument.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { template: \\u0026#39;\\u0026lt;ul id=\\u0026#34;todos\\u0026#34;\\u0026gt;\\u0026lt;/ul\\u0026gt;\\u0026#39; }); let todos = new Reef(\\u0026#39;#todos\\u0026#39;, { template: \\u0026#39;\\u0026lt;li\\u0026gt;Build something with Reef\\u0026lt;/li\\u0026gt;\\u0026#39; }); // Attach one item app.attach(todos); // Attach an array of items app.attach([todos]);  Reef.prototype.detach() Detach an attached component. Pass in the component or an array of components as an argument.\\n// Detach one component app.detach(todos); // Detach an array of components app.detach([todos]);  Reef.prototype.do() Run a setter function. Pass in the name of the setter, and a comma-separate list of any arguments.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { count: 0 }, template: function (props) { return count; }, setters: { increase: function (props) { props.count++; } } }); // Run the increase setter app.do(\\u0026#39;increase\\u0026#39;);  Reef.prototype.get() Run a getter function. Pass in the name of the getter, and a comma-separate list of any arguments.\\nlet app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { count: 0 }, template: function (props) { return count; }, getters: { count: function (props) { return props.count; } } }); // Run the count getter app.get(\\u0026#39;count\\u0026#39;);  Instance Properties Access these properties on individual Reef components.\\nReef.prototype.data Get a reactive copy of the app data.\\nlet data = app.data;  Reef.prototype.elem The element the component is associated with. Returns a string or Node.\\nlet elem = app.elem;  Reef.prototype.allowHTML Whether or not HTML is allowed in the Reef component data. Returns a boolean.\\nlet allowed = app.allowHTML;  Events Reef emits custom events throughout the lifecycle of a component or instance.\\nAll Reef events follow a reef:{event-name} pattern. Unless otherwise specified, all events are emitted on the document element. Event details can be accessed on the event.details property.\\n// Listen for when Reef components are rendered into the DOM document.addEventListener(\\u0026#39;reef:render\\u0026#39;, function (event) { console.log(event.target); // The element it was rendered into \\tconsole.log(event.detail); // The data used for the render });   reef:ready is emitted when Reef is loaded into the DOM and ready to use. reef:initialized is emitted when a new Reef component is initialized.  event.detail - the instance  reef:before-render is emitted on an element before a new UI is rendered into it.  event.target - the element the component is being rendered into event.detail - the current component data event.preventDefault() - stop the component from rendering  reef:render is emitted on an element after a new UI is rendered into it.  event.target - the element the component was rendered into event.detail - the component data at time of render  reef:attached is emitted when one or more components is attached to a component.  event.detail - an object with the component and an array of attached components  reef:detached is emitted when one or more components is detached from a component.  event.detail - an object with the component and an array of detached components   Options All of the options for Reef.\\n// This can be a string or a element let elem = \\u0026#39;#app\\u0026#39;; new Reef(elem, { // The component data \\tdata: {}, // A component or array of components to attach to \\tattachTo: [], // A data store to use \\t// If used, the data option is ignored \\tstore: null, // A router to use for this component \\trouter: null, // An object of setter methods \\tsetters: {}, // An object of getter methods \\tgetters: {} });  Demos Want to see Reef in action? Here are some demos and examples you can play with.\\n Clock Mirror Typing Pomodoro Timer Stopwatch Progress Bar Todo List Whack-a-Mole Game Articles from an API  Browser Compatibility Reef works in all modern browsers. That means:\\n The latest versions of Edge, Chrome, Firefox, and Safari. Mobile Safari, Chrome, and Firefox on Safari. WebView, Chrome, and Firefox for Android.  If you need to support older browsers, you\\u0026rsquo;ll need to transpile your code into ES5 with BabelJS.\\nLicense The code is available under the MIT License.\\n\",\"title\":\"Reef v9\",\"type\":\"versions\",\"url\":\"https://reefjs.com/v9/\"},{\"content\":\" Reef uses data reactivity to update your UI.\\nData reactivity means that the UI \\u0026ldquo;reacts\\u0026rdquo; to changes in your data. Update your data, and the UI automatically renders any required updates based on the new state.\\n// Create a component let app = new Reef(\\u0026#39;#app\\u0026#39;, { data: { greeting: \\u0026#39;Hello\\u0026#39;, name: \\u0026#39;world\\u0026#39; }, template: function (props) { return `\\u0026lt;h1\\u0026gt;${props.greeting}, ${props.name}!\\u0026lt;/h1\\u0026gt;`; } }); // Render the initial UI app.render(); // This causes component to update with \\u0026#34;Hi, universe\\u0026#34; app.data.greeting = \\u0026#39;Hi\\u0026#39;; app.data.name = \\u0026#39;Universe\\u0026#39;;  You can also update the entire data object.\\n// This will also update the UI app.data = { greeting: \\u0026#39;Hi\\u0026#39;, name: \\u0026#39;Universe\\u0026#39; };  Try data reactivity on CodePen \\u0026rarr;\\nFor better performance, multiple property updates may be batched into a single, asynchronous render. You can detect when a render has been completed using the reef:render event.\\nNon-Reactive Data Sometimes, you want to update data without updating the UI.\\nYou can get an immutable copy of your data with the Reef.prototype.dataCopy property. This returns an immutable, non-reactive copy of your data that won\\u0026rsquo;t affect the state of your component or cause a UI update.\\n// Get an immutable copy of the app.data let data = app.dataCopy; // Update the copy // This does NOT update the app.data or render a new UI data.name = \\u0026#39;Universe\\u0026#39;;  When you\\u0026rsquo;re ready to update your component data, you can set the component\\u0026rsquo;s data property to your cloned copy.\\n// Reactively update the component data app.data = data;  Try non-reactive data on CodePen \\u0026rarr;\\nGet Daily Developer Tips **Sick of over-engineered modern web developer \\\"best practices?\\\"** I send out a short email each weekday on how to build a simpler, more resilient web. Join 12,700+ others.\\nIf you're human, leave this blank  Enter your email address to get Daily Developer Tips emails  Get Daily Developer Tips     \",\"title\":\"State Management\",\"type\":\"page\",\"url\":\"https://reefjs.com/state-management/\"},{\"content\":\" Reef A lightweight library for creating reactive, state-based UI.\\nReef is a simpler alternative to React, Vue, and other large UI libraries.\\nGet started with Reef \\u0026rarr;\\nFeatures  Weighs just 3kb minified and gzipped, with zero dependencies. Simple templating with JavaScript strings or template literals. Load it with a \\u0026lt;script\\u0026gt; element or ES module import\\u0026mdash;no command line or transpiling required (though you can if you want). Uses DOM diffing to update only the things that have changed. Has Redux/Vuex-like data stores, with setters baked right in. Automatically sanitizes HTML before rendering to help protect you from cross-site scripting (XSS) attacks. Work with native JavaScript methods and browser APIs instead of custom methods and pseudo-languages. Compatible with all modern browsers.  Ditch that bloated framework, and make web development fun and simple again!\\nWhy use Reef? Reef is an anti-framework.\\nIt does a lot less than the big guys like React and Vue. It doesn\\u0026rsquo;t have a Virtual DOM. It doesn\\u0026rsquo;t require you to learn a custom templating syntax. It doesn\\u0026rsquo;t provide a bunch of custom methods.\\nReef does just one thing: render UI.\\nCouldn\\u0026rsquo;t you just use some template strings and innerHTML? Sure. But Reef only updates things that have changed instead of clobbering the DOM and removing focus from your form fields. It also automatically renders a new UI when your data updates, and helps protect you from XSS attacks.\\nIf you\\u0026rsquo;re craving a simpler, back-to-basics web development experience, Reef is for you.\\n(And if not, that\\u0026rsquo;s cool too! Carry on.)\\nGet started with Reef \\u0026rarr;\\nHi, I'm Chris Ferdinandi. 👋 I believe there’s a simpler, more resilient way to make things for the web.\\nI create vanilla JS pocket guides and video courses, run a project-based training program, and host the vanilla JS podcast. My developer tips newsletter is read by over {{mc_subs}} developers each weekday.\\nIf you have a question about something or need JavaScript help, get in touch.\\n Get Daily Developer Tips **Sick of over-engineered modern web developer \\\"best practices?\\\"** I send out a short email each weekday on how to build a simpler, more resilient web. Join 12,700+ others.\\nIf you're human, leave this blank  Enter your email address to get Daily Developer Tips emails  Get Daily Developer Tips     \",\"title\":\"\",\"type\":\"page\",\"url\":\"https://reefjs.com/\"},{\"content\":\"Copyright \\u0026copy; Chris Ferdinandi\\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\",\"title\":\"MIT License\",\"type\":\"page\",\"url\":\"https://reefjs.com/mit/\"},{\"content\":\"I can\\u0026rsquo;t seem to find the page you\\u0026rsquo;re looking for. Sorry! Send me an email me at \\u0026#099;\\u0026#104;\\u0026#114;\\u0026#105;\\u0026#115;\\u0026#064;\\u0026#103;\\u0026#111;\\u0026#109;\\u0026#097;\\u0026#107;\\u0026#101;\\u0026#116;\\u0026#104;\\u0026#105;\\u0026#110;\\u0026#103;\\u0026#115;\\u0026#046;\\u0026#099;\\u0026#111;\\u0026#109; and I\\u0026rsquo;ll help you find it.\\n\",\"title\":\"Oops!\",\"type\":\"page\",\"url\":\"https://reefjs.com/404/\"},{\"content\":\"\",\"title\":\"Categories\",\"type\":\"categories\",\"url\":\"https://reefjs.com/categories/\"},{\"content\":\"\",\"title\":\"Tags\",\"type\":\"tags\",\"url\":\"https://reefjs.com/tags/\"},{\"content\":\"\",\"title\":\"Versions\",\"type\":\"versions\",\"url\":\"https://reefjs.com/versions/\"}]");
	</script>

			</div>
		</main>

		<footer class="container container-large">
			<hr class="margin-bottom">
			<nav class="tabindex nav-secondary" id="nav-secondary" tabindex="-1">
	<ul class="list-inline list-inline-responsive">
		<li><a href="https://reefjs.com/getting-started">Getting Started</a></li><li><a href="https://reefjs.com/state-management">State Management</a></li><li><a href="https://reefjs.com/advanced">Advanced</a></li><li><a href="https://reefjs.com/api">API Reference</a></li></li><li><a href="https://reefjs.com/demos">Demos</a></li></li><li><a href="https://reefjs.com/about">v11.x</a></li>
		<li><a href="https://github.com/cferdinandi/reef">GitHub</a></li>
	</ul>
</nav>
			<p class="text-small">Made with ❤️ in Massachusetts by <a href="https://gomakethings.com">Chris Ferdinandi</a>. Unless otherwise noted, all code is free to use under the <a href="https://reefjs.com/mit">MIT License</a>.</p>
			<p class="text-small">Logo by <a href="https://thenounproject.com/term/coral/862368/">Lluis Pareras from the Noun Project</a>.</p>
		</footer>

		<script>
			/*! vanillajs v1.5.0 | (c) 2022 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/vanilla-js-toolkit */
!function(){"use strict";!function(e){let t=document.querySelector('[data-form="convertkit"]');if(!t)return;let x=t.querySelector("#email");if(!x)return;let n=t.querySelector("[data-status]"),r=t.querySelector("[data-processing]"),c="Please provide an email address.",a="Please use a valid email address.";function o(e,t){n&&(n.textContent=e,t?(n.classList.add("success-message"),n.classList.remove("error-message"),x.classList.remove("error")):(n.classList.add("error-message"),n.classList.remove("success-message"),x.classList.add("error")))}function s(){return x.value.length<1?(o(c),!1):!!/^([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d))*(\.\w{2,})+$/.test(x.value)||(o(a),!1)}t.addEventListener("submit",(function(e){e.preventDefault(),t.hasAttribute("data-submitting")||(o(r.getAttribute("data-processing"),!0),s()&&(t.setAttribute("data-submitting",""),fetch(t.action,{method:"POST",body:new FormData(t),headers:{Accept:"application/json"}}).then((function(e){if(e.ok)return e.json();throw e})).then((function(e){o(e.msg,!0),e.redirect&&(window.location.href=e.redirect)})).catch((function(e){e.json().then((function(e){o(e.msg)}))})).finally((function(){t.removeAttribute("data-submitting")}))))})),t.setAttribute("novalidate","")}(),document.querySelector("#table-of-contents")&&function(e,t,x,n,r){if(!e||!t)return;let c=document.querySelector(e);if(!c)return;document.querySelectorAll(t),r=r||"ul";let a=Array.from(document.querySelectorAll(t)).map((function(e){return e.id?`<li><a href="#${e.id}">${e.textContent}</a></li>`:""})).join("");a.length<1||(c.innerHTML=`${x||""}\n\t\t<${r}${n?` class="${n}"`:""}>\n\t\t\t${a}\n\t\t</${r}>`)}("#table-of-contents","h2",'<h2 class="h5">On this page</h2>',null,"ul"),document.body.matches(".js-anchors")&&function(e,t,x){if(!e)return;let n=document.querySelectorAll(e),r=document.createElement("a");r.textContent=t||"#",r.className=x||"anchor-link";for(let e of n){if(!e.id)continue;let t=r.cloneNode(!0);t.href="#"+e.id,e.append(" ",t)}}("h2, h3, h4, h5, h6","#","link-no-underline")}();

			/*! vanillajs v1.5.0 | (c) 2022 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/vanilla-js-toolkit */
!function(){"use strict";navigator&&navigator.serviceWorker&&navigator.serviceWorker.register("/sw.js"),navigator.serviceWorker.controller&&window.addEventListener("load",(function(){navigator.serviceWorker.controller.postMessage("cleanUp")}))}();

		</script>
	</body>
</html>